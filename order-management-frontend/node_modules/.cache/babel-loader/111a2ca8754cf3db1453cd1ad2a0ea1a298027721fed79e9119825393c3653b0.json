{"ast":null,"code":"import { v4 } from 'uuid';\nimport dayjs from 'dayjs';\nimport quarterOfYear from 'dayjs/plugin/quarterOfYear';\nimport en from 'dayjs/locale/en';\nimport { fromPairs, toPairs, equals, clone, indexBy, prop, mergeDeepLeft, pipe, map, filter, reduce, minBy, maxBy, flatten, pluck, mergeAll, uniq, dropLast, groupBy, unnest as unnest$1 } from 'ramda';\nimport fetch from 'cross-fetch';\nimport 'url-search-params-polyfill';\nconst DEFAULT_GRANULARITY = 'day';\nconst GRANULARITIES = [{\n  name: undefined,\n  title: 'w/o grouping'\n}, {\n  name: 'second',\n  title: 'Second'\n}, {\n  name: 'minute',\n  title: 'Minute'\n}, {\n  name: 'hour',\n  title: 'Hour'\n}, {\n  name: 'day',\n  title: 'Day'\n}, {\n  name: 'week',\n  title: 'Week'\n}, {\n  name: 'month',\n  title: 'Month'\n}, {\n  name: 'quarter',\n  title: 'Quarter'\n}, {\n  name: 'year',\n  title: 'Year'\n}];\nfunction removeEmptyQueryFields(_query) {\n  const query = _query || {};\n  return fromPairs(toPairs(query).map(([key, value]) => {\n    if (['measures', 'dimensions', 'segments', 'timeDimensions', 'filters'].includes(key)) {\n      if (Array.isArray(value) && value.length === 0) {\n        return null;\n      }\n    }\n    if (key === 'order' && value) {\n      if (Array.isArray(value) && !value.length) {\n        return null;\n      } else if (!Object.keys(value).length) {\n        return null;\n      }\n    }\n    return [key, value];\n  }).filter(Boolean));\n}\nfunction validateQuery(_query) {\n  const query = _query || {};\n  return removeEmptyQueryFields({\n    ...query,\n    filters: (query.filters || []).filter(f => f.operator),\n    timeDimensions: (query.timeDimensions || []).filter(td => !(!td.dateRange && !td.granularity))\n  });\n}\nfunction areQueriesEqual(query1 = {}, query2 = {}) {\n  return equals(Object.entries(query1 && query1.order || {}), Object.entries(query2 && query2.order || {})) && equals(query1, query2);\n}\nfunction defaultOrder(query) {\n  const granularity = (query.timeDimensions || []).find(d => d.granularity);\n  if (granularity) {\n    return {\n      [granularity.dimension]: 'asc'\n    };\n  } else if ((query.measures || []).length > 0 && (query.dimensions || []).length > 0) {\n    return {\n      [query.measures[0]]: 'desc'\n    };\n  } else if ((query.dimensions || []).length > 0) {\n    return {\n      [query.dimensions[0]]: 'asc'\n    };\n  }\n  return {};\n}\nfunction defaultHeuristics(newState, oldQuery = {}, options) {\n  const {\n    query,\n    ...props\n  } = clone(newState);\n  const {\n    meta,\n    sessionGranularity\n  } = options;\n  const granularity = sessionGranularity || DEFAULT_GRANULARITY;\n  let state = {\n    query,\n    ...props\n  };\n  let newQuery = null;\n  if (!areQueriesEqual(query, oldQuery)) {\n    newQuery = query;\n  }\n  if (Array.isArray(newQuery) || Array.isArray(oldQuery)) {\n    return newState;\n  }\n  if (newQuery) {\n    if ((oldQuery.timeDimensions || []).length === 1 && (newQuery.timeDimensions || []).length === 1 && newQuery.timeDimensions[0].granularity && oldQuery.timeDimensions[0].granularity !== newQuery.timeDimensions[0].granularity) {\n      state = {\n        ...state,\n        sessionGranularity: newQuery.timeDimensions[0].granularity\n      };\n    }\n    if ((oldQuery.measures || []).length === 0 && (newQuery.measures || []).length > 0 || (oldQuery.measures || []).length === 1 && (newQuery.measures || []).length === 1 && oldQuery.measures[0] !== newQuery.measures[0]) {\n      const [td] = newQuery.timeDimensions || [];\n      const defaultTimeDimension = meta.defaultTimeDimensionNameFor(newQuery.measures[0]);\n      newQuery = {\n        ...newQuery,\n        timeDimensions: defaultTimeDimension ? [{\n          dimension: defaultTimeDimension,\n          granularity: td && td.granularity || granularity,\n          dateRange: td && td.dateRange\n        }] : []\n      };\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: defaultTimeDimension ? 'line' : 'number'\n      };\n    }\n    if ((oldQuery.dimensions || []).length === 0 && (newQuery.dimensions || []).length > 0) {\n      newQuery = {\n        ...newQuery,\n        timeDimensions: (newQuery.timeDimensions || []).map(td => ({\n          ...td,\n          granularity: undefined\n        }))\n      };\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: 'table'\n      };\n    }\n    if ((oldQuery.dimensions || []).length > 0 && (newQuery.dimensions || []).length === 0) {\n      newQuery = {\n        ...newQuery,\n        timeDimensions: (newQuery.timeDimensions || []).map(td => ({\n          ...td,\n          granularity: td.granularity || granularity\n        }))\n      };\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: (newQuery.timeDimensions || []).length ? 'line' : 'number'\n      };\n    }\n    if (((oldQuery.dimensions || []).length > 0 || (oldQuery.measures || []).length > 0) && (newQuery.dimensions || []).length === 0 && (newQuery.measures || []).length === 0) {\n      newQuery = {\n        ...newQuery,\n        timeDimensions: [],\n        filters: []\n      };\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        sessionGranularity: null\n      };\n    }\n    return state;\n  }\n  if (state.chartType) {\n    const newChartType = state.chartType;\n    if ((newChartType === 'line' || newChartType === 'area') && (oldQuery.timeDimensions || []).length === 1 && !oldQuery.timeDimensions[0].granularity) {\n      const [td] = oldQuery.timeDimensions;\n      return {\n        ...state,\n        pivotConfig: null,\n        query: {\n          ...oldQuery,\n          timeDimensions: [{\n            ...td,\n            granularity\n          }]\n        }\n      };\n    }\n    if ((newChartType === 'pie' || newChartType === 'table' || newChartType === 'number') && (oldQuery.timeDimensions || []).length === 1 && oldQuery.timeDimensions[0].granularity) {\n      const [td] = oldQuery.timeDimensions;\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: {\n          ...oldQuery,\n          timeDimensions: [{\n            ...td,\n            granularity: undefined\n          }]\n        }\n      };\n    }\n  }\n  return state;\n}\nfunction isQueryPresent(query) {\n  if (!query) {\n    return false;\n  }\n  return (Array.isArray(query) ? query : [query]).every(q => q.measures && q.measures.length || q.dimensions && q.dimensions.length || q.timeDimensions && q.timeDimensions.length);\n}\nfunction movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis) {\n  const nextPivotConfig = {\n    ...pivotConfig,\n    x: [...pivotConfig.x],\n    y: [...pivotConfig.y]\n  };\n  const id = pivotConfig[sourceAxis][sourceIndex];\n  const lastIndex = nextPivotConfig[destinationAxis].length - 1;\n  if (id === 'measures') {\n    destinationIndex = lastIndex + 1;\n  } else if (sourceAxis === destinationAxis && destinationIndex >= lastIndex && nextPivotConfig[destinationAxis][lastIndex] === 'measures') {\n    destinationIndex = lastIndex - 1;\n  } else if (sourceAxis !== destinationAxis && destinationIndex > lastIndex && nextPivotConfig[destinationAxis][lastIndex] === 'measures') {\n    destinationIndex = lastIndex;\n  }\n  nextPivotConfig[sourceAxis].splice(sourceIndex, 1);\n  nextPivotConfig[destinationAxis].splice(destinationIndex, 0, id);\n  return nextPivotConfig;\n}\nfunction moveItemInArray(list, sourceIndex, destinationIndex) {\n  const result = [...list];\n  const [removed] = result.splice(sourceIndex, 1);\n  result.splice(destinationIndex, 0, removed);\n  return result;\n}\nfunction flattenFilters(filters = []) {\n  return filters.reduce((memo, filter) => {\n    if (filter.or || filter.and) {\n      return [...memo, ...flattenFilters(filter.or || filter.and)];\n    }\n    return [...memo, filter];\n  }, []);\n}\nfunction getQueryMembers(query = {}) {\n  const keys = ['measures', 'dimensions', 'segments'];\n  const members = new Set();\n  keys.forEach(key => (query[key] || []).forEach(member => members.add(member)));\n  (query.timeDimensions || []).forEach(td => members.add(td.dimension));\n  flattenFilters(query.filters).forEach(filter => members.add(filter.dimension || filter.member));\n  return [...members];\n}\nfunction getOrderMembersFromOrder(orderMembers, order) {\n  const ids = new Set();\n  const indexedOrderMembers = indexBy(prop('id'), orderMembers);\n  const entries = Array.isArray(order) ? order : Object.entries(order || {});\n  const nextOrderMembers = [];\n  entries.forEach(([memberId, currentOrder]) => {\n    if (currentOrder !== 'none' && indexedOrderMembers[memberId]) {\n      ids.add(memberId);\n      nextOrderMembers.push({\n        ...indexedOrderMembers[memberId],\n        order: currentOrder\n      });\n    }\n  });\n  orderMembers.forEach(member => {\n    if (!ids.has(member.id)) {\n      nextOrderMembers.push({\n        ...member,\n        order: member.order || 'none'\n      });\n    }\n  });\n  return nextOrderMembers;\n}\nfunction aliasSeries(values, index, pivotConfig, duplicateMeasures) {\n  const nonNullValues = values.filter(value => value != null);\n  if (pivotConfig && pivotConfig.aliasSeries && pivotConfig.aliasSeries[index]) {\n    return [pivotConfig.aliasSeries[index], ...nonNullValues];\n  } else if (duplicateMeasures.has(nonNullValues[0])) {\n    return [index, ...nonNullValues];\n  }\n  return nonNullValues;\n}\ndayjs.extend(quarterOfYear);\n\n// When granularity is week, weekStart Value must be 1. However, since the client can change it globally (https://day.js.org/docs/en/i18n/changing-locale)\n// So the function below has been added.\nconst internalDayjs = (...args) => dayjs(...args).locale({\n  ...en,\n  weekStart: 1\n});\nconst TIME_SERIES = {\n  day: range => range.by('d').map(d => d.format('YYYY-MM-DDT00:00:00.000')),\n  month: range => range.snapTo('month').by('M').map(d => d.format('YYYY-MM-01T00:00:00.000')),\n  year: range => range.snapTo('year').by('y').map(d => d.format('YYYY-01-01T00:00:00.000')),\n  hour: range => range.by('h').map(d => d.format('YYYY-MM-DDTHH:00:00.000')),\n  minute: range => range.by('m').map(d => d.format('YYYY-MM-DDTHH:mm:00.000')),\n  second: range => range.by('s').map(d => d.format('YYYY-MM-DDTHH:mm:ss.000')),\n  week: range => range.snapTo('week').by('w').map(d => d.startOf('week').format('YYYY-MM-DDT00:00:00.000')),\n  quarter: range => range.snapTo('quarter').by('quarter').map(d => d.startOf('quarter').format('YYYY-MM-DDT00:00:00.000'))\n};\nconst DateRegex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\nconst LocalDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z?$/;\nconst groupByToPairs = keyFn => {\n  const acc = new Map();\n  return data => {\n    data.forEach(row => {\n      const key = keyFn(row);\n      if (!acc.has(key)) {\n        acc.set(key, []);\n      }\n      acc.get(key).push(row);\n    });\n    return Array.from(acc.entries());\n  };\n};\nconst unnest = arr => {\n  const res = [];\n  arr.forEach(subArr => {\n    subArr.forEach(element => res.push(element));\n  });\n  return res;\n};\nconst dayRange = (from, to) => ({\n  by: value => {\n    const results = [];\n    let start = internalDayjs(from);\n    const end = internalDayjs(to);\n    while (start.isBefore(end) || start.isSame(end)) {\n      results.push(start);\n      start = start.add(1, value);\n    }\n    return results;\n  },\n  snapTo: value => dayRange(internalDayjs(from).startOf(value), internalDayjs(to).endOf(value)),\n  start: internalDayjs(from),\n  end: internalDayjs(to)\n});\nconst QUERY_TYPE = {\n  REGULAR_QUERY: 'regularQuery',\n  COMPARE_DATE_RANGE_QUERY: 'compareDateRangeQuery',\n  BLENDING_QUERY: 'blendingQuery'\n};\nclass ResultSet {\n  static measureFromAxis(axisValues) {\n    return axisValues[axisValues.length - 1];\n  }\n  static timeDimensionMember(td) {\n    return `${td.dimension}.${td.granularity}`;\n  }\n  static deserialize(data, options = {}) {\n    return new ResultSet(data.loadResponse, options);\n  }\n  constructor(loadResponse, options = {}) {\n    this.loadResponse = loadResponse;\n    if (this.loadResponse.queryType != null) {\n      this.queryType = loadResponse.queryType;\n      this.loadResponses = loadResponse.results;\n    } else {\n      this.queryType = QUERY_TYPE.REGULAR_QUERY;\n      this.loadResponse.pivotQuery = {\n        ...loadResponse.query,\n        queryType: this.queryType\n      };\n      this.loadResponses = [loadResponse];\n    }\n    if (!Object.values(QUERY_TYPE).includes(this.queryType)) {\n      throw new Error('Unknown query type');\n    }\n    this.parseDateMeasures = options.parseDateMeasures;\n    this.options = options;\n    this.backwardCompatibleData = [];\n  }\n  drillDown(drillDownLocator, pivotConfig) {\n    if (this.queryType === QUERY_TYPE.COMPARE_DATE_RANGE_QUERY) {\n      throw new Error('compareDateRange drillDown query is not currently supported');\n    }\n    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n      throw new Error('Data blending drillDown query is not currently supported');\n    }\n    const {\n      query\n    } = this.loadResponses[0];\n    const {\n      xValues = [],\n      yValues = []\n    } = drillDownLocator;\n    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);\n    const values = [];\n    normalizedPivotConfig.x.forEach((member, currentIndex) => values.push([member, xValues[currentIndex]]));\n    normalizedPivotConfig.y.forEach((member, currentIndex) => values.push([member, yValues[currentIndex]]));\n    const {\n      filters: parentFilters = [],\n      segments = []\n    } = this.query();\n    const {\n      measures\n    } = this.loadResponses[0].annotation;\n    let [, measureName] = values.find(([member]) => member === 'measures') || [];\n    if (measureName === undefined) {\n      [measureName] = Object.keys(measures);\n    }\n    if (!(measures[measureName] && measures[measureName].drillMembers || []).length) {\n      return null;\n    }\n    const filters = [{\n      member: measureName,\n      operator: 'measureFilter'\n    }, ...parentFilters];\n    const timeDimensions = [];\n    values.filter(([member]) => member !== 'measures').forEach(([member, value]) => {\n      const [cubeName, dimension, granularity] = member.split('.');\n      if (granularity !== undefined) {\n        const range = dayRange(value, value).snapTo(granularity);\n        const originalTimeDimension = query.timeDimensions.find(td => td.dimension);\n        let dateRange = [range.start, range.end];\n        if (originalTimeDimension?.dateRange) {\n          const [originalStart, originalEnd] = originalTimeDimension.dateRange;\n          dateRange = [dayjs(originalStart) > range.start ? dayjs(originalStart) : range.start, dayjs(originalEnd) < range.end ? dayjs(originalEnd) : range.end];\n        }\n        timeDimensions.push({\n          dimension: [cubeName, dimension].join('.'),\n          dateRange: dateRange.map(dt => dt.format('YYYY-MM-DDTHH:mm:ss.SSS'))\n        });\n      } else if (value == null) {\n        filters.push({\n          member,\n          operator: 'notSet'\n        });\n      } else {\n        filters.push({\n          member,\n          operator: 'equals',\n          values: [value.toString()]\n        });\n      }\n    });\n    if (timeDimensions.length === 0 && query.timeDimensions.length > 0 && query.timeDimensions[0].granularity == null) {\n      timeDimensions.push(query.timeDimensions[0]);\n    }\n    return {\n      ...measures[measureName].drillMembersGrouped,\n      filters,\n      ...(segments.length > 0 ? {\n        segments\n      } : {}),\n      timeDimensions,\n      segments,\n      timezone: query.timezone\n    };\n  }\n  series(pivotConfig) {\n    return this.seriesNames(pivotConfig).map(({\n      title,\n      shortTitle,\n      key\n    }) => ({\n      title,\n      shortTitle,\n      key,\n      series: this.chartPivot(pivotConfig).map(({\n        x,\n        ...obj\n      }) => ({\n        value: obj[key],\n        x\n      }))\n    }));\n  }\n  axisValues(axis, resultIndex = 0) {\n    const {\n      query\n    } = this.loadResponses[resultIndex];\n    return row => {\n      const value = measure => axis.filter(d => d !== 'measures').map(d => row[d] != null ? row[d] : null).concat(measure ? [measure] : []);\n      if (axis.find(d => d === 'measures') && (query.measures || []).length) {\n        return query.measures.map(value);\n      }\n      return [value()];\n    };\n  }\n  axisValuesString(axisValues, delimiter) {\n    const formatValue = v => {\n      if (v == null) {\n        return 'âˆ…';\n      } else if (v === '') {\n        return '[Empty string]';\n      } else {\n        return v;\n      }\n    };\n    return axisValues.map(formatValue).join(delimiter || ', ');\n  }\n  static getNormalizedPivotConfig(query = {}, pivotConfig = null) {\n    const defaultPivotConfig = {\n      x: [],\n      y: [],\n      fillMissingDates: true,\n      joinDateRange: false\n    };\n    const {\n      measures = [],\n      dimensions = []\n    } = query;\n    const timeDimensions = (query.timeDimensions || []).filter(td => !!td.granularity);\n    pivotConfig = pivotConfig || (timeDimensions.length ? {\n      x: timeDimensions.map(td => ResultSet.timeDimensionMember(td)),\n      y: dimensions\n    } : {\n      x: dimensions,\n      y: []\n    });\n    pivotConfig = mergeDeepLeft(pivotConfig, defaultPivotConfig);\n    const substituteTimeDimensionMembers = axis => axis.map(subDim => timeDimensions.find(td => td.dimension === subDim) && !dimensions.find(d => d === subDim) ? ResultSet.timeDimensionMember(query.timeDimensions.find(td => td.dimension === subDim)) : subDim);\n    pivotConfig.x = substituteTimeDimensionMembers(pivotConfig.x);\n    pivotConfig.y = substituteTimeDimensionMembers(pivotConfig.y);\n    const allIncludedDimensions = pivotConfig.x.concat(pivotConfig.y);\n    const allDimensions = timeDimensions.map(td => ResultSet.timeDimensionMember(td)).concat(dimensions);\n    const dimensionFilter = key => allDimensions.includes(key) || key === 'measures';\n    pivotConfig.x = pivotConfig.x.concat(allDimensions.filter(d => !allIncludedDimensions.includes(d) && d !== 'compareDateRange')).filter(dimensionFilter);\n    pivotConfig.y = pivotConfig.y.filter(dimensionFilter);\n    if (!pivotConfig.x.concat(pivotConfig.y).find(d => d === 'measures')) {\n      pivotConfig.y.push('measures');\n    }\n    if (dimensions.includes('compareDateRange') && !pivotConfig.y.concat(pivotConfig.x).includes('compareDateRange')) {\n      pivotConfig.y.unshift('compareDateRange');\n    }\n    if (!measures.length) {\n      pivotConfig.x = pivotConfig.x.filter(d => d !== 'measures');\n      pivotConfig.y = pivotConfig.y.filter(d => d !== 'measures');\n    }\n    return pivotConfig;\n  }\n  normalizePivotConfig(pivotConfig) {\n    return ResultSet.getNormalizedPivotConfig(this.loadResponse.pivotQuery, pivotConfig);\n  }\n  timeSeries(timeDimension, resultIndex) {\n    if (!timeDimension.granularity) {\n      return null;\n    }\n    let {\n      dateRange\n    } = timeDimension;\n    if (!dateRange) {\n      const member = ResultSet.timeDimensionMember(timeDimension);\n      const dates = pipe(map(row => row[member] && internalDayjs(row[member])), filter(Boolean))(this.timeDimensionBackwardCompatibleData(resultIndex));\n      dateRange = dates.length && [reduce(minBy(d => d.toDate()), dates[0], dates), reduce(maxBy(d => d.toDate()), dates[0], dates)] || null;\n    }\n    if (!dateRange) {\n      return null;\n    }\n    const padToDay = timeDimension.dateRange ? timeDimension.dateRange.find(d => d.match(DateRegex)) : !['hour', 'minute', 'second'].includes(timeDimension.granularity);\n    const [start, end] = dateRange;\n    const range = dayRange(start, end);\n    if (!TIME_SERIES[timeDimension.granularity]) {\n      throw new Error(`Unsupported time granularity: ${timeDimension.granularity}`);\n    }\n    return TIME_SERIES[timeDimension.granularity](padToDay ? range.snapTo('d') : range);\n  }\n  pivot(pivotConfig) {\n    pivotConfig = this.normalizePivotConfig(pivotConfig);\n    const {\n      pivotQuery: query\n    } = this.loadResponse;\n    const pivotImpl = (resultIndex = 0) => {\n      let groupByXAxis = groupByToPairs(({\n        xValues\n      }) => this.axisValuesString(xValues));\n      const measureValue = (row, measure) => row[measure] || 0;\n      if (pivotConfig.fillMissingDates && pivotConfig.x.length === 1 && equals(pivotConfig.x, (query.timeDimensions || []).filter(td => Boolean(td.granularity)).map(td => ResultSet.timeDimensionMember(td)))) {\n        const series = this.loadResponses.map(loadResponse => this.timeSeries(loadResponse.query.timeDimensions[0], resultIndex));\n        if (series[0]) {\n          groupByXAxis = rows => {\n            const byXValues = groupBy(({\n              xValues\n            }) => xValues[0], rows);\n            return series[resultIndex].map(d => [d, byXValues[d] || [{\n              xValues: [d],\n              row: {}\n            }]]);\n          };\n        }\n      }\n      const xGrouped = pipe(map(row => this.axisValues(pivotConfig.x, resultIndex)(row).map(xValues => ({\n        xValues,\n        row\n      }))), unnest, groupByXAxis)(this.timeDimensionBackwardCompatibleData(resultIndex));\n      const yValuesMap = {};\n      xGrouped.forEach(([, rows]) => {\n        rows.forEach(({\n          row\n        }) => {\n          this.axisValues(pivotConfig.y, resultIndex)(row).forEach(values => {\n            if (Object.keys(row).length > 0) {\n              yValuesMap[values.join()] = values;\n            }\n          });\n        });\n      });\n      const allYValues = Object.values(yValuesMap);\n      const measureOnX = Boolean(pivotConfig.x.find(d => d === 'measures'));\n      return xGrouped.map(([, rows]) => {\n        const {\n          xValues\n        } = rows[0];\n        const yGrouped = {};\n        rows.forEach(({\n          row\n        }) => {\n          const arr = this.axisValues(pivotConfig.y, resultIndex)(row).map(yValues => ({\n            yValues,\n            row\n          }));\n          arr.forEach(res => {\n            yGrouped[this.axisValuesString(res.yValues)] = res;\n          });\n        });\n        return {\n          xValues,\n          yValuesArray: unnest(allYValues.map(yValues => {\n            const measure = measureOnX ? ResultSet.measureFromAxis(xValues) : ResultSet.measureFromAxis(yValues);\n            return [[yValues, measureValue((yGrouped[this.axisValuesString(yValues)] || {\n              row: {}\n            }).row, measure)]];\n          }))\n        };\n      });\n    };\n    const pivots = this.loadResponses.length > 1 ? this.loadResponses.map((_, index) => pivotImpl(index)) : [];\n    return pivots.length ? this.mergePivots(pivots, pivotConfig.joinDateRange) : pivotImpl();\n  }\n  mergePivots(pivots, joinDateRange) {\n    const minLengthPivot = pivots.reduce((memo, current) => memo != null && current.length >= memo.length ? memo : current, null);\n    return minLengthPivot.map((_, index) => {\n      const xValues = joinDateRange ? [pivots.map(pivot => pivot[index] && pivot[index].xValues || []).join(', ')] : minLengthPivot[index].xValues;\n      return {\n        xValues,\n        yValuesArray: unnest(pivots.map(pivot => pivot[index].yValuesArray))\n      };\n    });\n  }\n  pivotedRows(pivotConfig) {\n    // TODO\n    return this.chartPivot(pivotConfig);\n  }\n  chartPivot(pivotConfig) {\n    const validate = value => {\n      if (this.parseDateMeasures && LocalDateRegex.test(value)) {\n        return new Date(value);\n      } else if (!Number.isNaN(Number.parseFloat(value))) {\n        return Number.parseFloat(value);\n      }\n      return value;\n    };\n    const duplicateMeasures = new Set();\n    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n      const allMeasures = flatten(this.loadResponses.map(({\n        query\n      }) => query.measures));\n      allMeasures.filter((e, i, a) => a.indexOf(e) !== i).forEach(m => duplicateMeasures.add(m));\n    }\n    return this.pivot(pivotConfig).map(({\n      xValues,\n      yValuesArray\n    }) => {\n      const yValuesMap = {};\n      yValuesArray.forEach(([yValues, m], i) => {\n        yValuesMap[this.axisValuesString(aliasSeries(yValues, i, pivotConfig, duplicateMeasures), ',')] = m && validate(m);\n      });\n      return {\n        x: this.axisValuesString(xValues, ','),\n        xValues,\n        ...yValuesMap\n      };\n    });\n  }\n  tablePivot(pivotConfig) {\n    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});\n    const isMeasuresPresent = normalizedPivotConfig.x.concat(normalizedPivotConfig.y).includes('measures');\n    return this.pivot(normalizedPivotConfig).map(({\n      xValues,\n      yValuesArray\n    }) => fromPairs(normalizedPivotConfig.x.map((key, index) => [key, xValues[index]]).concat(isMeasuresPresent ? yValuesArray.map(([yValues, measure]) => [yValues.length ? yValues.join() : 'value', measure]) : [])));\n  }\n  tableColumns(pivotConfig) {\n    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});\n    const annotations = pipe(pluck('annotation'), reduce(mergeDeepLeft(), {}))(this.loadResponses);\n    const flatMeta = Object.values(annotations).reduce((a, b) => ({\n      ...a,\n      ...b\n    }), {});\n    const schema = {};\n    const extractFields = key => {\n      const {\n        title,\n        shortTitle,\n        type,\n        format,\n        meta\n      } = flatMeta[key] || {};\n      return {\n        key,\n        title,\n        shortTitle,\n        type,\n        format,\n        meta\n      };\n    };\n    const pivot = this.pivot(normalizedPivotConfig);\n    (pivot[0] && pivot[0].yValuesArray || []).forEach(([yValues]) => {\n      if (yValues.length > 0) {\n        let currentItem = schema;\n        yValues.forEach((value, index) => {\n          currentItem[`_${value}`] = {\n            key: value,\n            memberId: normalizedPivotConfig.y[index] === 'measures' ? value : normalizedPivotConfig.y[index],\n            children: currentItem[`_${value}`] && currentItem[`_${value}`].children || {}\n          };\n          currentItem = currentItem[`_${value}`].children;\n        });\n      }\n    });\n    const toColumns = (item = {}, path = []) => {\n      if (Object.keys(item).length === 0) {\n        return [];\n      }\n      return Object.values(item).map(({\n        key,\n        ...currentItem\n      }) => {\n        const children = toColumns(currentItem.children, [...path, key]);\n        const {\n          title,\n          shortTitle,\n          ...fields\n        } = extractFields(currentItem.memberId);\n        const dimensionValue = key !== currentItem.memberId || title == null ? key : '';\n        if (!children.length) {\n          return {\n            ...fields,\n            key,\n            dataIndex: [...path, key].join(),\n            title: [title, dimensionValue].join(' ').trim(),\n            shortTitle: dimensionValue || shortTitle\n          };\n        }\n        return {\n          ...fields,\n          key,\n          title: [title, dimensionValue].join(' ').trim(),\n          shortTitle: dimensionValue || shortTitle,\n          children\n        };\n      });\n    };\n    let otherColumns = [];\n    if (!pivot.length && normalizedPivotConfig.y.includes('measures')) {\n      otherColumns = (this.loadResponses[0].query.measures || []).map(key => ({\n        ...extractFields(key),\n        dataIndex: key\n      }));\n    }\n\n    // Syntatic column to display the measure value\n    if (!normalizedPivotConfig.y.length && normalizedPivotConfig.x.includes('measures')) {\n      otherColumns.push({\n        key: 'value',\n        dataIndex: 'value',\n        title: 'Value',\n        shortTitle: 'Value',\n        type: 'string'\n      });\n    }\n    return normalizedPivotConfig.x.map(key => {\n      if (key === 'measures') {\n        return {\n          key: 'measures',\n          dataIndex: 'measures',\n          title: 'Measures',\n          shortTitle: 'Measures',\n          type: 'string'\n        };\n      }\n      return {\n        ...extractFields(key),\n        dataIndex: key\n      };\n    }).concat(toColumns(schema)).concat(otherColumns);\n  }\n  totalRow(pivotConfig) {\n    return this.chartPivot(pivotConfig)[0];\n  }\n  categories(pivotConfig) {\n    // TODO\n    return this.chartPivot(pivotConfig);\n  }\n  seriesNames(pivotConfig) {\n    pivotConfig = this.normalizePivotConfig(pivotConfig);\n    const measures = pipe(pluck('annotation'), pluck('measures'), mergeAll)(this.loadResponses);\n    const seriesNames = unnest(this.loadResponses.map((_, index) => pipe(map(this.axisValues(pivotConfig.y, index)), unnest, uniq)(this.timeDimensionBackwardCompatibleData(index))));\n    const duplicateMeasures = new Set();\n    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n      const allMeasures = flatten(this.loadResponses.map(({\n        query\n      }) => query.measures));\n      allMeasures.filter((e, i, a) => a.indexOf(e) !== i).forEach(m => duplicateMeasures.add(m));\n    }\n    return seriesNames.map((axisValues, i) => {\n      const aliasedAxis = aliasSeries(axisValues, i, pivotConfig, duplicateMeasures);\n      return {\n        title: this.axisValuesString(pivotConfig.y.find(d => d === 'measures') ? dropLast(1, aliasedAxis).concat(measures[ResultSet.measureFromAxis(axisValues)].title) : aliasedAxis, ', '),\n        shortTitle: this.axisValuesString(pivotConfig.y.find(d => d === 'measures') ? dropLast(1, aliasedAxis).concat(measures[ResultSet.measureFromAxis(axisValues)].shortTitle) : aliasedAxis, ', '),\n        key: this.axisValuesString(aliasedAxis, ','),\n        yValues: axisValues\n      };\n    });\n  }\n  query() {\n    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);\n    }\n    return this.loadResponses[0].query;\n  }\n  pivotQuery() {\n    return this.loadResponse.pivotQuery || null;\n  }\n  totalRows() {\n    return this.loadResponses[0].total;\n  }\n  rawData() {\n    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);\n    }\n    return this.loadResponses[0].data;\n  }\n  annotation() {\n    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);\n    }\n    return this.loadResponses[0].annotation;\n  }\n  timeDimensionBackwardCompatibleData(resultIndex) {\n    if (resultIndex === undefined) {\n      throw new Error('resultIndex is required');\n    }\n    if (!this.backwardCompatibleData[resultIndex]) {\n      const {\n        data,\n        query\n      } = this.loadResponses[resultIndex];\n      const timeDimensions = (query.timeDimensions || []).filter(td => Boolean(td.granularity));\n      this.backwardCompatibleData[resultIndex] = data.map(row => ({\n        ...row,\n        ...fromPairs(Object.keys(row).filter(field => timeDimensions.find(d => d.dimension === field) && !row[ResultSet.timeDimensionMember(timeDimensions.find(d => d.dimension === field))]).map(field => [ResultSet.timeDimensionMember(timeDimensions.find(d => d.dimension === field)), row[field]]))\n      }));\n    }\n    return this.backwardCompatibleData[resultIndex];\n  }\n  decompose() {\n    return this.loadResponses.map(result => new ResultSet({\n      queryType: QUERY_TYPE.REGULAR_QUERY,\n      pivotQuery: {\n        ...result.query,\n        queryType: QUERY_TYPE.REGULAR_QUERY\n      },\n      results: [result]\n    }, this.options));\n  }\n  serialize() {\n    return {\n      loadResponse: clone(this.loadResponse)\n    };\n  }\n}\nclass SqlQuery {\n  constructor(sqlQuery) {\n    this.sqlQuery = sqlQuery;\n  }\n  rawQuery() {\n    return this.sqlQuery.sql;\n  }\n  sql() {\n    return this.rawQuery().sql[0];\n  }\n}\n\n/**\n * @module @cubejs-client/core\n */\nconst memberMap = memberArray => fromPairs(memberArray.map(m => [m.name, m]));\nconst operators = {\n  string: [{\n    name: 'contains',\n    title: 'contains'\n  }, {\n    name: 'notContains',\n    title: 'does not contain'\n  }, {\n    name: 'equals',\n    title: 'equals'\n  }, {\n    name: 'notEquals',\n    title: 'does not equal'\n  }, {\n    name: 'set',\n    title: 'is set'\n  }, {\n    name: 'notSet',\n    title: 'is not set'\n  }, {\n    name: 'startsWith',\n    title: 'starts with'\n  }, {\n    name: 'notStartsWith',\n    title: 'does not start with'\n  }, {\n    name: 'endsWith',\n    title: 'ends with'\n  }, {\n    name: 'notEndsWith',\n    title: 'does not end with'\n  }],\n  number: [{\n    name: 'equals',\n    title: 'equals'\n  }, {\n    name: 'notEquals',\n    title: 'does not equal'\n  }, {\n    name: 'set',\n    title: 'is set'\n  }, {\n    name: 'notSet',\n    title: 'is not set'\n  }, {\n    name: 'gt',\n    title: '>'\n  }, {\n    name: 'gte',\n    title: '>='\n  }, {\n    name: 'lt',\n    title: '<'\n  }, {\n    name: 'lte',\n    title: '<='\n  }],\n  time: [{\n    name: 'equals',\n    title: 'equals'\n  }, {\n    name: 'notEquals',\n    title: 'does not equal'\n  }, {\n    name: 'inDateRange',\n    title: 'in date range'\n  }, {\n    name: 'notInDateRange',\n    title: 'not in date range'\n  }, {\n    name: 'afterDate',\n    title: 'after date'\n  }, {\n    name: 'afterOrOnDate',\n    title: 'after or on date'\n  }, {\n    name: 'beforeDate',\n    title: 'before date'\n  }, {\n    name: 'beforeOrOnDate',\n    title: 'before or on date'\n  }]\n};\n\n/**\n * Contains information about available cubes and it's members.\n */\nclass Meta {\n  constructor(metaResponse) {\n    this.meta = metaResponse;\n    const {\n      cubes\n    } = this.meta;\n    this.cubes = cubes;\n    this.cubesMap = fromPairs(cubes.map(c => [c.name, {\n      measures: memberMap(c.measures),\n      dimensions: memberMap(c.dimensions),\n      segments: memberMap(c.segments)\n    }]));\n  }\n  membersForQuery(query, memberType) {\n    return unnest$1(this.cubes.map(c => c[memberType])).sort((a, b) => a.title > b.title ? 1 : -1);\n  }\n  membersGroupedByCube() {\n    const memberKeys = ['measures', 'dimensions', 'segments', 'timeDimensions'];\n    return this.cubes.reduce((memo, cube) => {\n      memberKeys.forEach(key => {\n        let members = cube[key];\n        if (key === 'timeDimensions') {\n          members = cube.dimensions.filter(m => m.type === 'time');\n        }\n        memo[key] = [...memo[key], {\n          cubeName: cube.name,\n          cubeTitle: cube.title,\n          type: cube.type,\n          public: cube.public,\n          members\n        }];\n      });\n      return memo;\n    }, {\n      measures: [],\n      dimensions: [],\n      segments: [],\n      timeDimensions: []\n    });\n  }\n  resolveMember(memberName, memberType) {\n    const [cube] = memberName.split('.');\n    if (!this.cubesMap[cube]) {\n      return {\n        title: memberName,\n        error: `Cube not found ${cube} for path '${memberName}'`\n      };\n    }\n    const memberTypes = Array.isArray(memberType) ? memberType : [memberType];\n    const member = memberTypes.map(type => this.cubesMap[cube][type] && this.cubesMap[cube][type][memberName]).find(m => m);\n    if (!member) {\n      return {\n        title: memberName,\n        error: `Path not found '${memberName}'`\n      };\n    }\n    return member;\n  }\n  defaultTimeDimensionNameFor(memberName) {\n    const [cube] = memberName.split('.');\n    if (!this.cubesMap[cube]) {\n      return null;\n    }\n    return Object.keys(this.cubesMap[cube].dimensions || {}).find(d => this.cubesMap[cube].dimensions[d].type === 'time');\n  }\n  filterOperatorsForMember(memberName, memberType) {\n    const member = this.resolveMember(memberName, memberType);\n    return operators[member.type] || operators.string;\n  }\n}\nclass ProgressResult {\n  constructor(progressResponse) {\n    this.progressResponse = progressResponse;\n  }\n  stage() {\n    return this.progressResponse.stage;\n  }\n  timeElapsed() {\n    return this.progressResponse.timeElapsed;\n  }\n}\nclass HttpTransport {\n  constructor({\n    authorization,\n    apiUrl,\n    method,\n    headers = {},\n    credentials\n  }) {\n    this.authorization = authorization;\n    this.apiUrl = apiUrl;\n    this.method = method;\n    this.headers = headers;\n    this.credentials = credentials;\n  }\n  request(method, {\n    baseRequestId,\n    ...params\n  }) {\n    let spanCounter = 1;\n    const searchParams = new URLSearchParams(params && Object.keys(params).map(k => ({\n      [k]: typeof params[k] === 'object' ? JSON.stringify(params[k]) : params[k]\n    })).reduce((a, b) => ({\n      ...a,\n      ...b\n    }), {}));\n    let url = `${this.apiUrl}/${method}${searchParams.toString().length ? `?${searchParams}` : ''}`;\n    const requestMethod = this.method || (url.length < 2000 ? 'GET' : 'POST');\n    if (requestMethod === 'POST') {\n      url = `${this.apiUrl}/${method}`;\n      this.headers['Content-Type'] = 'application/json';\n    }\n\n    // Currently, all methods make GET requests. If a method makes a request with a body payload,\n    // remember to add {'Content-Type': 'application/json'} to the header.\n    const runRequest = () => fetch(url, {\n      method: requestMethod,\n      headers: {\n        Authorization: this.authorization,\n        'x-request-id': baseRequestId && `${baseRequestId}-span-${spanCounter++}`,\n        ...this.headers\n      },\n      credentials: this.credentials,\n      body: requestMethod === 'POST' ? JSON.stringify(params) : null\n    });\n    return {\n      /* eslint no-unsafe-finally: off */\n      async subscribe(callback) {\n        let result = {\n          error: 'network Error' // add default error message\n        };\n        try {\n          result = await runRequest();\n        } finally {\n          return callback(result, () => this.subscribe(callback));\n        }\n      }\n    };\n  }\n}\nclass RequestError extends Error {\n  constructor(message, response, status) {\n    super(message);\n    this.response = response;\n    this.status = status;\n  }\n}\nlet mutexCounter = 0;\nconst MUTEX_ERROR = 'Mutex has been changed';\n\n/**\n * Query result dataset formats enum.\n */\nconst ResultType = {\n  DEFAULT: 'default',\n  COMPACT: 'compact'\n};\nfunction mutexPromise(promise) {\n  return new Promise(async (resolve, reject) => {\n    try {\n      resolve(await promise);\n    } catch (error) {\n      if (error !== MUTEX_ERROR) {\n        reject(error);\n      }\n    }\n  });\n}\nclass CubeApi {\n  constructor(apiToken, options) {\n    if (apiToken !== null && !Array.isArray(apiToken) && typeof apiToken === 'object') {\n      options = apiToken;\n      apiToken = undefined;\n    }\n    options = options || {};\n    if (!options.transport && !options.apiUrl) {\n      throw new Error('The `apiUrl` option is required');\n    }\n    this.apiToken = apiToken;\n    this.apiUrl = options.apiUrl;\n    this.method = options.method;\n    this.headers = options.headers || {};\n    this.credentials = options.credentials;\n    this.transport = options.transport || new HttpTransport({\n      authorization: typeof apiToken === 'function' ? undefined : apiToken,\n      apiUrl: this.apiUrl,\n      method: this.method,\n      headers: this.headers,\n      credentials: this.credentials\n    });\n    this.pollInterval = options.pollInterval || 5;\n    this.parseDateMeasures = options.parseDateMeasures;\n    this.castNumerics = typeof options.castNumerics === 'boolean' ? options.castNumerics : false;\n    this.updateAuthorizationPromise = null;\n  }\n  request(method, params) {\n    return this.transport.request(method, {\n      baseRequestId: v4(),\n      ...params\n    });\n  }\n  loadMethod(request, toResult, options, callback) {\n    const mutexValue = ++mutexCounter;\n    if (typeof options === 'function' && !callback) {\n      callback = options;\n      options = undefined;\n    }\n    options = options || {};\n    const mutexKey = options.mutexKey || 'default';\n    if (options.mutexObj) {\n      options.mutexObj[mutexKey] = mutexValue;\n    }\n    const requestPromise = this.updateTransportAuthorization().then(() => request());\n    let skipAuthorizationUpdate = true;\n    let unsubscribed = false;\n    const checkMutex = async () => {\n      const requestInstance = await requestPromise;\n      if (options.mutexObj && options.mutexObj[mutexKey] !== mutexValue) {\n        unsubscribed = true;\n        if (requestInstance.unsubscribe) {\n          await requestInstance.unsubscribe();\n        }\n        throw MUTEX_ERROR;\n      }\n    };\n    const loadImpl = async (response, next) => {\n      const requestInstance = await requestPromise;\n      const subscribeNext = async () => {\n        if (options.subscribe && !unsubscribed) {\n          if (requestInstance.unsubscribe) {\n            return next();\n          } else {\n            await new Promise(resolve => setTimeout(() => resolve(), this.pollInterval * 1000));\n            return next();\n          }\n        }\n        return null;\n      };\n      const continueWait = async wait => {\n        if (!unsubscribed) {\n          if (wait) {\n            await new Promise(resolve => setTimeout(() => resolve(), this.pollInterval * 1000));\n          }\n          return next();\n        }\n        return null;\n      };\n      if (options.subscribe && !skipAuthorizationUpdate) {\n        await this.updateTransportAuthorization();\n      }\n      skipAuthorizationUpdate = false;\n      if (response.status === 502) {\n        await checkMutex();\n        return continueWait(true);\n      }\n      let body = {};\n      let text = '';\n      try {\n        text = await response.text();\n        body = JSON.parse(text);\n      } catch (_) {\n        body.error = text;\n      }\n      if (body.error === 'Continue wait') {\n        await checkMutex();\n        if (options.progressCallback) {\n          options.progressCallback(new ProgressResult(body));\n        }\n        return continueWait();\n      }\n      if (response.status !== 200) {\n        await checkMutex();\n        if (!options.subscribe && requestInstance.unsubscribe) {\n          await requestInstance.unsubscribe();\n        }\n        const error = new RequestError(body.error, body, response.status); // TODO error class\n        if (callback) {\n          callback(error);\n        } else {\n          throw error;\n        }\n        return subscribeNext();\n      }\n      await checkMutex();\n      if (!options.subscribe && requestInstance.unsubscribe) {\n        await requestInstance.unsubscribe();\n      }\n      const result = toResult(body);\n      if (callback) {\n        callback(null, result);\n      } else {\n        return result;\n      }\n      return subscribeNext();\n    };\n    const promise = requestPromise.then(requestInstance => mutexPromise(requestInstance.subscribe(loadImpl)));\n    if (callback) {\n      return {\n        unsubscribe: async () => {\n          const requestInstance = await requestPromise;\n          unsubscribed = true;\n          if (requestInstance.unsubscribe) {\n            return requestInstance.unsubscribe();\n          }\n          return null;\n        }\n      };\n    } else {\n      return promise;\n    }\n  }\n  async updateTransportAuthorization() {\n    if (this.updateAuthorizationPromise) {\n      await this.updateAuthorizationPromise;\n      return;\n    }\n    if (typeof this.apiToken === 'function') {\n      this.updateAuthorizationPromise = new Promise(async (resolve, reject) => {\n        try {\n          const token = await this.apiToken();\n          if (this.transport.authorization !== token) {\n            this.transport.authorization = token;\n          }\n          resolve();\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.updateAuthorizationPromise = null;\n        }\n      });\n      await this.updateAuthorizationPromise;\n    }\n  }\n\n  /**\n   * Add system properties to a query object.\n   * @param {Query} query\n   * @param {string} responseFormat\n   * @returns {void}\n   * @private\n   */\n  patchQueryInternal(query, responseFormat) {\n    if (responseFormat === ResultType.COMPACT && query.responseFormat !== ResultType.COMPACT) {\n      return {\n        ...query,\n        responseFormat: ResultType.COMPACT\n      };\n    } else {\n      return query;\n    }\n  }\n\n  /**\n   * Process result fetched from the gateway#load method according\n   * to the network protocol.\n   * @param {*} response\n   * @returns ResultSet\n   * @private\n   */\n  loadResponseInternal(response, options = {}) {\n    if (response.results.length) {\n      if (options.castNumerics) {\n        response.results.forEach(result => {\n          const numericMembers = Object.entries({\n            ...result.annotation.measures,\n            ...result.annotation.dimensions\n          }).map(([k, v]) => {\n            if (v.type === 'number') {\n              return k;\n            }\n            return undefined;\n          }).filter(Boolean);\n          result.data = result.data.map(row => {\n            numericMembers.forEach(key => {\n              if (row[key] != null) {\n                row[key] = Number(row[key]);\n              }\n            });\n            return row;\n          });\n        });\n      }\n      if (response.results[0].query.responseFormat && response.results[0].query.responseFormat === ResultType.COMPACT) {\n        response.results.forEach((result, j) => {\n          const data = [];\n          result.data.dataset.forEach(r => {\n            const row = {};\n            result.data.members.forEach((m, i) => {\n              row[m] = r[i];\n            });\n            data.push(row);\n          });\n          response.results[j].data = data;\n        });\n      }\n    }\n    return new ResultSet(response, {\n      parseDateMeasures: this.parseDateMeasures\n    });\n  }\n  load(query, options, callback, responseFormat = ResultType.DEFAULT) {\n    options = {\n      castNumerics: this.castNumerics,\n      ...options\n    };\n    if (responseFormat === ResultType.COMPACT) {\n      if (Array.isArray(query)) {\n        query = query.map(q => this.patchQueryInternal(q, ResultType.COMPACT));\n      } else {\n        query = this.patchQueryInternal(query, ResultType.COMPACT);\n      }\n    }\n    return this.loadMethod(() => this.request('load', {\n      query,\n      queryType: 'multi'\n    }), response => this.loadResponseInternal(response, options), options, callback);\n  }\n  subscribe(query, options, callback, responseFormat = ResultType.DEFAULT) {\n    options = {\n      castNumerics: this.castNumerics,\n      ...options\n    };\n    if (responseFormat === ResultType.COMPACT) {\n      if (Array.isArray(query)) {\n        query = query.map(q => this.patchQueryInternal(q, ResultType.COMPACT));\n      } else {\n        query = this.patchQueryInternal(query, ResultType.COMPACT);\n      }\n    }\n    return this.loadMethod(() => this.request('subscribe', {\n      query,\n      queryType: 'multi'\n    }), response => this.loadResponseInternal(response, options), {\n      ...options,\n      subscribe: true\n    }, callback);\n  }\n  sql(query, options, callback) {\n    return this.loadMethod(() => this.request('sql', {\n      query\n    }), response => Array.isArray(response) ? response.map(body => new SqlQuery(body)) : new SqlQuery(response), options, callback);\n  }\n  meta(options, callback) {\n    return this.loadMethod(() => this.request('meta'), body => new Meta(body), options, callback);\n  }\n  dryRun(query, options, callback) {\n    return this.loadMethod(() => this.request('dry-run', {\n      query\n    }), response => response, options, callback);\n  }\n}\nvar index = (apiToken, options) => new CubeApi(apiToken, options);\nexport default index;\nexport { CubeApi, DEFAULT_GRANULARITY, GRANULARITIES, HttpTransport, Meta, RequestError, ResultSet, aliasSeries, areQueriesEqual, defaultHeuristics, defaultOrder, flattenFilters, getOrderMembersFromOrder, getQueryMembers, isQueryPresent, moveItemInArray, movePivotItem, removeEmptyQueryFields, validateQuery };","map":{"version":3,"names":["DEFAULT_GRANULARITY","GRANULARITIES","name","undefined","title","removeEmptyQueryFields","_query","query","fromPairs","toPairs","map","key","value","includes","Array","isArray","length","Object","keys","filter","Boolean","validateQuery","filters","f","operator","timeDimensions","td","dateRange","granularity","areQueriesEqual","query1","query2","equals","entries","order","defaultOrder","find","d","dimension","measures","dimensions","defaultHeuristics","newState","oldQuery","options","props","clone","meta","sessionGranularity","state","newQuery","defaultTimeDimension","defaultTimeDimensionNameFor","pivotConfig","shouldApplyHeuristicOrder","chartType","newChartType","isQueryPresent","every","q","movePivotItem","sourceIndex","destinationIndex","sourceAxis","destinationAxis","nextPivotConfig","x","y","id","lastIndex","splice","moveItemInArray","list","result","removed","flattenFilters","reduce","memo","or","and","getQueryMembers","members","Set","forEach","member","add","getOrderMembersFromOrder","orderMembers","ids","indexedOrderMembers","indexBy","prop","nextOrderMembers","memberId","currentOrder","push","has","aliasSeries","values","index","duplicateMeasures","nonNullValues","dayjs","extend","quarterOfYear","internalDayjs","args","locale","en","weekStart","TIME_SERIES","day","range","by","format","month","snapTo","year","hour","minute","second","week","startOf","quarter","DateRegex","LocalDateRegex","groupByToPairs","keyFn","acc","Map","data","row","set","get","from","unnest","arr","res","subArr","element","dayRange","to","results","start","end","isBefore","isSame","endOf","QUERY_TYPE","REGULAR_QUERY","COMPARE_DATE_RANGE_QUERY","BLENDING_QUERY","ResultSet","measureFromAxis","axisValues","timeDimensionMember","deserialize","loadResponse","constructor","queryType","loadResponses","pivotQuery","Error","parseDateMeasures","backwardCompatibleData","drillDown","drillDownLocator","xValues","yValues","normalizedPivotConfig","normalizePivotConfig","currentIndex","parentFilters","segments","annotation","measureName","drillMembers","cubeName","split","originalTimeDimension","originalStart","originalEnd","join","dt","toString","drillMembersGrouped","timezone","series","seriesNames","shortTitle","chartPivot","obj","axis","resultIndex","measure","concat","axisValuesString","delimiter","formatValue","v","getNormalizedPivotConfig","defaultPivotConfig","fillMissingDates","joinDateRange","mergeDeepLeft","substituteTimeDimensionMembers","subDim","allIncludedDimensions","allDimensions","dimensionFilter","unshift","timeSeries","timeDimension","dates","pipe","timeDimensionBackwardCompatibleData","minBy","toDate","maxBy","padToDay","match","pivot","pivotImpl","groupByXAxis","measureValue","rows","byXValues","groupBy","xGrouped","yValuesMap","allYValues","measureOnX","yGrouped","yValuesArray","pivots","_","mergePivots","minLengthPivot","current","pivotedRows","validate","test","Date","Number","isNaN","parseFloat","allMeasures","flatten","e","i","a","indexOf","m","tablePivot","isMeasuresPresent","tableColumns","annotations","pluck","flatMeta","b","schema","extractFields","type","currentItem","children","toColumns","item","path","fields","dimensionValue","dataIndex","trim","otherColumns","totalRow","categories","mergeAll","uniq","aliasedAxis","dropLast","totalRows","total","rawData","field","decompose","serialize","SqlQuery","sqlQuery","rawQuery","sql","memberMap","memberArray","operators","string","number","time","Meta","metaResponse","cubes","cubesMap","c","membersForQuery","memberType","unnest$1","sort","membersGroupedByCube","memberKeys","cube","cubeTitle","public","resolveMember","memberName","error","memberTypes","filterOperatorsForMember","ProgressResult","progressResponse","stage","timeElapsed","HttpTransport","authorization","apiUrl","method","headers","credentials","request","baseRequestId","params","spanCounter","searchParams","URLSearchParams","k","JSON","stringify","url","requestMethod","runRequest","fetch","Authorization","body","subscribe","callback","RequestError","message","response","status","mutexCounter","MUTEX_ERROR","ResultType","DEFAULT","COMPACT","mutexPromise","promise","Promise","resolve","reject","CubeApi","apiToken","transport","pollInterval","castNumerics","updateAuthorizationPromise","v4","loadMethod","toResult","mutexValue","mutexKey","mutexObj","requestPromise","updateTransportAuthorization","then","skipAuthorizationUpdate","unsubscribed","checkMutex","requestInstance","unsubscribe","loadImpl","next","subscribeNext","setTimeout","continueWait","wait","text","parse","progressCallback","token","patchQueryInternal","responseFormat","loadResponseInternal","numericMembers","j","dataset","r","load","dryRun"],"sources":["C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\utils.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\ResultSet.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\SqlQuery.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\Meta.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\ProgressResult.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\HttpTransport.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\RequestError.js","C:\\Users\\Dell\\Documents\\code\\order-management\\order-management-frontend\\node_modules\\@cubejs-client\\core\\src\\index.js"],"sourcesContent":["import { indexBy, prop, clone, equals, fromPairs, toPairs } from 'ramda';\n\nexport const DEFAULT_GRANULARITY = 'day';\n\nexport const GRANULARITIES = [\n  { name: undefined, title: 'w/o grouping' },\n  { name: 'second', title: 'Second' },\n  { name: 'minute', title: 'Minute' },\n  { name: 'hour', title: 'Hour' },\n  { name: 'day', title: 'Day' },\n  { name: 'week', title: 'Week' },\n  { name: 'month', title: 'Month' },\n  { name: 'quarter', title: 'Quarter' },\n  { name: 'year', title: 'Year' },\n];\n\nexport function removeEmptyQueryFields(_query) {\n  const query = _query || {};\n  \n  return fromPairs(\n    toPairs(query)\n      .map(([key, value]) => {\n        if (\n          ['measures', 'dimensions', 'segments', 'timeDimensions', 'filters'].includes(key)\n        ) {\n          if (Array.isArray(value) && value.length === 0) {\n            return null;\n          }\n        }\n        \n        if (key === 'order' && value) {\n          if (Array.isArray(value) && !value.length) {\n            return null;\n          } else if (!Object.keys(value).length) {\n            return null;\n          }\n        }\n\n        return [key, value];\n      })\n      .filter(Boolean)\n  );\n}\n\nexport function validateQuery(_query) {\n  const query = _query || {};\n  \n  return removeEmptyQueryFields({\n    ...query,\n    filters: (query.filters || []).filter((f) => f.operator),\n    timeDimensions: (query.timeDimensions || []).filter(\n      (td) => !(!td.dateRange && !td.granularity)\n    ),\n  });\n}\n\nexport function areQueriesEqual(query1 = {}, query2 = {}) {\n  return (\n    equals(\n      Object.entries((query1 && query1.order) || {}),\n      Object.entries((query2 && query2.order) || {})\n    ) && equals(query1, query2)\n  );\n}\n\nexport function defaultOrder(query) {\n  const granularity = (query.timeDimensions || []).find((d) => d.granularity);\n\n  if (granularity) {\n    return {\n      [granularity.dimension]: 'asc',\n    };\n  } else if (\n    (query.measures || []).length > 0 &&\n    (query.dimensions || []).length > 0\n  ) {\n    return {\n      [query.measures[0]]: 'desc',\n    };\n  } else if ((query.dimensions || []).length > 0) {\n    return {\n      [query.dimensions[0]]: 'asc',\n    };\n  }\n\n  return {};\n}\n\nexport function defaultHeuristics(newState, oldQuery = {}, options) {\n  const { query, ...props } = clone(newState);\n  const { meta, sessionGranularity } = options;\n  const granularity = sessionGranularity || DEFAULT_GRANULARITY;\n\n  let state = {\n    query,\n    ...props,\n  };\n\n  let newQuery = null;\n  if (!areQueriesEqual(query, oldQuery)) {\n    newQuery = query;\n  }\n\n  if (Array.isArray(newQuery) || Array.isArray(oldQuery)) {\n    return newState;\n  }\n\n  if (newQuery) {\n    if (\n      (oldQuery.timeDimensions || []).length === 1 &&\n      (newQuery.timeDimensions || []).length === 1 &&\n      newQuery.timeDimensions[0].granularity &&\n      oldQuery.timeDimensions[0].granularity !==\n        newQuery.timeDimensions[0].granularity\n    ) {\n      state = {\n        ...state,\n        sessionGranularity: newQuery.timeDimensions[0].granularity,\n      };\n    }\n\n    if (\n      ((oldQuery.measures || []).length === 0 &&\n        (newQuery.measures || []).length > 0) ||\n      ((oldQuery.measures || []).length === 1 &&\n        (newQuery.measures || []).length === 1 &&\n        oldQuery.measures[0] !== newQuery.measures[0])\n    ) {\n      const [td] = newQuery.timeDimensions || [];\n      const defaultTimeDimension = meta.defaultTimeDimensionNameFor(\n        newQuery.measures[0]\n      );\n      newQuery = {\n        ...newQuery,\n        timeDimensions: defaultTimeDimension\n          ? [\n            {\n              dimension: defaultTimeDimension,\n              granularity: (td && td.granularity) || granularity,\n              dateRange: td && td.dateRange,\n            },\n          ]\n          : [],\n      };\n\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: defaultTimeDimension ? 'line' : 'number',\n      };\n    }\n\n    if (\n      (oldQuery.dimensions || []).length === 0 &&\n      (newQuery.dimensions || []).length > 0\n    ) {\n      newQuery = {\n        ...newQuery,\n        timeDimensions: (newQuery.timeDimensions || []).map((td) => ({\n          ...td,\n          granularity: undefined,\n        })),\n      };\n\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: 'table',\n      };\n    }\n\n    if (\n      (oldQuery.dimensions || []).length > 0 &&\n      (newQuery.dimensions || []).length === 0\n    ) {\n      newQuery = {\n        ...newQuery,\n        timeDimensions: (newQuery.timeDimensions || []).map((td) => ({\n          ...td,\n          granularity: td.granularity || granularity,\n        })),\n      };\n\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: (newQuery.timeDimensions || []).length ? 'line' : 'number',\n      };\n    }\n\n    if (\n      ((oldQuery.dimensions || []).length > 0 ||\n        (oldQuery.measures || []).length > 0) &&\n      (newQuery.dimensions || []).length === 0 &&\n      (newQuery.measures || []).length === 0\n    ) {\n      newQuery = {\n        ...newQuery,\n        timeDimensions: [],\n        filters: [],\n      };\n\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        sessionGranularity: null,\n      };\n    }\n    return state;\n  }\n\n  if (state.chartType) {\n    const newChartType = state.chartType;\n    if (\n      (newChartType === 'line' || newChartType === 'area') &&\n      (oldQuery.timeDimensions || []).length === 1 &&\n      !oldQuery.timeDimensions[0].granularity\n    ) {\n      const [td] = oldQuery.timeDimensions;\n      return {\n        ...state,\n        pivotConfig: null,\n        query: {\n          ...oldQuery,\n          timeDimensions: [{ ...td, granularity }],\n        },\n      };\n    }\n\n    if (\n      (newChartType === 'pie' ||\n        newChartType === 'table' ||\n        newChartType === 'number') &&\n      (oldQuery.timeDimensions || []).length === 1 &&\n      oldQuery.timeDimensions[0].granularity\n    ) {\n      const [td] = oldQuery.timeDimensions;\n      return {\n        ...state,\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: {\n          ...oldQuery,\n          timeDimensions: [{ ...td, granularity: undefined }],\n        },\n      };\n    }\n  }\n\n  return state;\n}\n\nexport function isQueryPresent(query) {\n  if (!query) {\n    return false;\n  }\n\n  return (Array.isArray(query) ? query : [query]).every(\n    (q) => (q.measures && q.measures.length) ||\n      (q.dimensions && q.dimensions.length) ||\n      (q.timeDimensions && q.timeDimensions.length)\n  );\n}\n\nexport function movePivotItem(\n  pivotConfig,\n  sourceIndex,\n  destinationIndex,\n  sourceAxis,\n  destinationAxis\n) {\n  const nextPivotConfig = {\n    ...pivotConfig,\n    x: [...pivotConfig.x],\n    y: [...pivotConfig.y],\n  };\n  const id = pivotConfig[sourceAxis][sourceIndex];\n  const lastIndex = nextPivotConfig[destinationAxis].length - 1;\n\n  if (id === 'measures') {\n    destinationIndex = lastIndex + 1;\n  } else if (\n    sourceAxis === destinationAxis &&\n    destinationIndex >= lastIndex &&\n    nextPivotConfig[destinationAxis][lastIndex] === 'measures'\n  ) {\n    destinationIndex = lastIndex - 1;\n  } else if (\n    sourceAxis !== destinationAxis &&\n    destinationIndex > lastIndex &&\n    nextPivotConfig[destinationAxis][lastIndex] === 'measures'\n  ) {\n    destinationIndex = lastIndex;\n  }\n\n  nextPivotConfig[sourceAxis].splice(sourceIndex, 1);\n  nextPivotConfig[destinationAxis].splice(destinationIndex, 0, id);\n\n  return nextPivotConfig;\n}\n\nexport function moveItemInArray(list, sourceIndex, destinationIndex) {\n  const result = [...list];\n  const [removed] = result.splice(sourceIndex, 1);\n  result.splice(destinationIndex, 0, removed);\n\n  return result;\n}\n\nexport function flattenFilters(filters = []) {\n  return filters.reduce((memo, filter) => {\n    if (filter.or || filter.and) {\n      return [...memo, ...flattenFilters(filter.or || filter.and)];\n    }\n\n    return [...memo, filter];\n  }, []);\n}\n\nexport function getQueryMembers(query = {}) {\n  const keys = ['measures', 'dimensions', 'segments'];\n  const members = new Set();\n\n  keys.forEach((key) => (query[key] || []).forEach((member) => members.add(member)));\n  (query.timeDimensions || []).forEach((td) => members.add(td.dimension));\n\n  flattenFilters(query.filters).forEach((filter) => members.add(filter.dimension || filter.member));\n\n  return [...members];\n}\n\nexport function getOrderMembersFromOrder(orderMembers, order) {\n  const ids = new Set();\n  const indexedOrderMembers = indexBy(prop('id'), orderMembers);\n  const entries = Array.isArray(order) ? order : Object.entries(order || {});\n  const nextOrderMembers = [];\n\n  entries.forEach(([memberId, currentOrder]) => {\n    if (currentOrder !== 'none' && indexedOrderMembers[memberId]) {\n      ids.add(memberId);\n      nextOrderMembers.push({\n        ...indexedOrderMembers[memberId],\n        order: currentOrder,\n      });\n    }\n  });\n  orderMembers.forEach((member) => {\n    if (!ids.has(member.id)) {\n      nextOrderMembers.push({\n        ...member,\n        order: member.order || 'none',\n      });\n    }\n  });\n\n  return nextOrderMembers;\n}\n\nexport function aliasSeries(values, index, pivotConfig, duplicateMeasures) {\n  const nonNullValues = values.filter((value) => value != null);\n\n  if (\n    pivotConfig &&\n    pivotConfig.aliasSeries &&\n    pivotConfig.aliasSeries[index]\n  ) {\n    return [pivotConfig.aliasSeries[index], ...nonNullValues];\n  } else if (duplicateMeasures.has(nonNullValues[0])) {\n    return [index, ...nonNullValues];\n  }\n\n  return nonNullValues;\n}\n","import dayjs from 'dayjs';\nimport quarterOfYear from 'dayjs/plugin/quarterOfYear';\n\nimport en from 'dayjs/locale/en';\nimport {\n  groupBy, pipe, fromPairs, uniq, filter, map, dropLast, equals, reduce, minBy, maxBy, clone, mergeDeepLeft,\n  pluck, mergeAll, flatten,\n} from 'ramda';\n\nimport { aliasSeries } from './utils';\n\ndayjs.extend(quarterOfYear);\n\n// When granularity is week, weekStart Value must be 1. However, since the client can change it globally (https://day.js.org/docs/en/i18n/changing-locale)\n// So the function below has been added.\nconst internalDayjs = (...args) => dayjs(...args).locale({ ...en, weekStart: 1 });\n\nexport const TIME_SERIES = {\n  day: (range) => range.by('d').map(d => d.format('YYYY-MM-DDT00:00:00.000')),\n  month: (range) => range.snapTo('month').by('M').map(d => d.format('YYYY-MM-01T00:00:00.000')),\n  year: (range) => range.snapTo('year').by('y').map(d => d.format('YYYY-01-01T00:00:00.000')),\n  hour: (range) => range.by('h').map(d => d.format('YYYY-MM-DDTHH:00:00.000')),\n  minute: (range) => range.by('m').map(d => d.format('YYYY-MM-DDTHH:mm:00.000')),\n  second: (range) => range.by('s').map(d => d.format('YYYY-MM-DDTHH:mm:ss.000')),\n  week: (range) => range.snapTo('week').by('w').map(d => d.startOf('week').format('YYYY-MM-DDT00:00:00.000')),\n  quarter: (range) => range.snapTo('quarter').by('quarter').map(d => d.startOf('quarter').format('YYYY-MM-DDT00:00:00.000')),\n};\n\nconst DateRegex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\nconst LocalDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z?$/;\n\nconst groupByToPairs = (keyFn) => {\n  const acc = new Map();\n\n  return (data) => {\n    data.forEach((row) => {\n      const key = keyFn(row);\n\n      if (!acc.has(key)) {\n        acc.set(key, []);\n      }\n\n      acc.get(key).push(row);\n    });\n\n    return Array.from(acc.entries());\n  };\n};\n\nconst unnest = (arr) => {\n  const res = [];\n  arr.forEach((subArr) => {\n    subArr.forEach(element => res.push(element));\n  });\n\n  return res;\n};\n\nexport const dayRange = (from, to) => ({\n  by: (value) => {\n    const results = [];\n\n    let start = internalDayjs(from);\n    const end = internalDayjs(to);\n\n    while (start.isBefore(end) || start.isSame(end)) {\n      results.push(start);\n      start = start.add(1, value);\n    }\n\n    return results;\n  },\n  snapTo: (value) => dayRange(internalDayjs(from).startOf(value), internalDayjs(to).endOf(value)),\n  start: internalDayjs(from),\n  end: internalDayjs(to),\n});\n\nexport const QUERY_TYPE = {\n  REGULAR_QUERY: 'regularQuery',\n  COMPARE_DATE_RANGE_QUERY: 'compareDateRangeQuery',\n  BLENDING_QUERY: 'blendingQuery',\n};\n\nclass ResultSet {\n  static measureFromAxis(axisValues) {\n    return axisValues[axisValues.length - 1];\n  }\n\n  static timeDimensionMember(td) {\n    return `${td.dimension}.${td.granularity}`;\n  }\n\n  static deserialize(data, options = {}) {\n    return new ResultSet(data.loadResponse, options);\n  }\n\n  constructor(loadResponse, options = {}) {\n    this.loadResponse = loadResponse;\n\n    if (this.loadResponse.queryType != null) {\n      this.queryType = loadResponse.queryType;\n      this.loadResponses = loadResponse.results;\n    } else {\n      this.queryType = QUERY_TYPE.REGULAR_QUERY;\n      this.loadResponse.pivotQuery = {\n        ...loadResponse.query,\n        queryType: this.queryType\n      };\n      this.loadResponses = [loadResponse];\n    }\n\n    if (!Object.values(QUERY_TYPE).includes(this.queryType)) {\n      throw new Error('Unknown query type');\n    }\n\n    this.parseDateMeasures = options.parseDateMeasures;\n    this.options = options;\n\n    this.backwardCompatibleData = [];\n  }\n\n  drillDown(drillDownLocator, pivotConfig) {\n    if (this.queryType === QUERY_TYPE.COMPARE_DATE_RANGE_QUERY) {\n      throw new Error('compareDateRange drillDown query is not currently supported');\n    }\n    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n      throw new Error('Data blending drillDown query is not currently supported');\n    }\n\n    const { query } = this.loadResponses[0];\n    const { xValues = [], yValues = [] } = drillDownLocator;\n    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);\n\n    const values = [];\n    normalizedPivotConfig.x.forEach((member, currentIndex) => values.push([member, xValues[currentIndex]]));\n    normalizedPivotConfig.y.forEach((member, currentIndex) => values.push([member, yValues[currentIndex]]));\n\n    const { filters: parentFilters = [], segments = [] } = this.query();\n    const { measures } = this.loadResponses[0].annotation;\n    let [, measureName] = values.find(([member]) => member === 'measures') || [];\n\n    if (measureName === undefined) {\n      [measureName] = Object.keys(measures);\n    }\n\n    if (!(measures[measureName] && measures[measureName].drillMembers || []).length) {\n      return null;\n    }\n\n    const filters = [\n      {\n        member: measureName,\n        operator: 'measureFilter',\n      },\n      ...parentFilters\n    ];\n    const timeDimensions = [];\n\n    values.filter(([member]) => member !== 'measures')\n      .forEach(([member, value]) => {\n        const [cubeName, dimension, granularity] = member.split('.');\n\n        if (granularity !== undefined) {\n          const range = dayRange(value, value).snapTo(granularity);\n          const originalTimeDimension = query.timeDimensions.find((td) => td.dimension);\n          \n          let dateRange = [\n            range.start,\n            range.end\n          ];\n          \n          if (originalTimeDimension?.dateRange) {\n            const [originalStart, originalEnd] = originalTimeDimension.dateRange;\n            \n            dateRange = [\n              dayjs(originalStart) > range.start ? dayjs(originalStart) : range.start,\n              dayjs(originalEnd) < range.end ? dayjs(originalEnd) : range.end,\n            ];\n          }\n\n          timeDimensions.push({\n            dimension: [cubeName, dimension].join('.'),\n            dateRange: dateRange.map((dt) => dt.format('YYYY-MM-DDTHH:mm:ss.SSS')),\n          });\n        } else if (value == null) {\n          filters.push({\n            member,\n            operator: 'notSet',\n          });\n        } else {\n          filters.push({\n            member,\n            operator: 'equals',\n            values: [value.toString()],\n          });\n        }\n      });\n    \n    if (\n      timeDimensions.length === 0 &&\n      query.timeDimensions.length > 0 &&\n      query.timeDimensions[0].granularity == null\n    ) {\n      timeDimensions.push(query.timeDimensions[0]);\n    }\n\n    return {\n      ...measures[measureName].drillMembersGrouped,\n      filters,\n      ...(segments.length > 0 ? { segments } : {}),\n      timeDimensions,\n      segments,\n      timezone: query.timezone\n    };\n  }\n\n  series(pivotConfig) {\n    return this.seriesNames(pivotConfig).map(({ title, shortTitle, key }) => ({\n      title,\n      shortTitle,\n      key,\n      series: this.chartPivot(pivotConfig).map(({ x, ...obj }) => ({ value: obj[key], x }))\n    }));\n  }\n\n  axisValues(axis, resultIndex = 0) {\n    const { query } = this.loadResponses[resultIndex];\n\n    return row => {\n      const value = (measure) => axis.filter(d => d !== 'measures')\n        .map(d => (row[d] != null ? row[d] : null)).concat(measure ? [measure] : []);\n\n      if (axis.find(d => d === 'measures') && (query.measures || []).length) {\n        return query.measures.map(value);\n      }\n\n      return [value()];\n    };\n  }\n\n  axisValuesString(axisValues, delimiter) {\n    const formatValue = (v) => {\n      if (v == null) {\n        return 'âˆ…';\n      } else if (v === '') {\n        return '[Empty string]';\n      } else {\n        return v;\n      }\n    };\n    return axisValues.map(formatValue).join(delimiter || ', ');\n  }\n\n  static getNormalizedPivotConfig(query = {}, pivotConfig = null) {\n    const defaultPivotConfig = {\n      x: [],\n      y: [],\n      fillMissingDates: true,\n      joinDateRange: false\n    };\n\n    const {\n      measures = [],\n      dimensions = []\n    } = query;\n\n    const timeDimensions = (query.timeDimensions || []).filter(td => !!td.granularity);\n\n    pivotConfig = pivotConfig || (timeDimensions.length ? {\n      x: timeDimensions.map(td => ResultSet.timeDimensionMember(td)),\n      y: dimensions\n    } : {\n      x: dimensions,\n      y: []\n    });\n\n    pivotConfig = mergeDeepLeft(pivotConfig, defaultPivotConfig);\n\n    const substituteTimeDimensionMembers = axis => axis.map(\n      subDim => (\n        (\n          timeDimensions.find(td => td.dimension === subDim) &&\n          !dimensions.find(d => d === subDim)\n        ) ?\n          ResultSet.timeDimensionMember(query.timeDimensions.find(td => td.dimension === subDim)) :\n          subDim\n      )\n    );\n\n    pivotConfig.x = substituteTimeDimensionMembers(pivotConfig.x);\n    pivotConfig.y = substituteTimeDimensionMembers(pivotConfig.y);\n\n    const allIncludedDimensions = pivotConfig.x.concat(pivotConfig.y);\n    const allDimensions = timeDimensions.map(td => ResultSet.timeDimensionMember(td)).concat(dimensions);\n\n    const dimensionFilter = (key) => allDimensions.includes(key) || key === 'measures';\n\n    pivotConfig.x = pivotConfig.x.concat(\n      allDimensions.filter(d => !allIncludedDimensions.includes(d) && d !== 'compareDateRange')\n    )\n      .filter(dimensionFilter);\n    pivotConfig.y = pivotConfig.y.filter(dimensionFilter);\n\n    if (!pivotConfig.x.concat(pivotConfig.y).find(d => d === 'measures')) {\n      pivotConfig.y.push('measures');\n    }\n\n    if (dimensions.includes('compareDateRange') && !pivotConfig.y.concat(pivotConfig.x).includes('compareDateRange')) {\n      pivotConfig.y.unshift('compareDateRange');\n    }\n\n    if (!measures.length) {\n      pivotConfig.x = pivotConfig.x.filter(d => d !== 'measures');\n      pivotConfig.y = pivotConfig.y.filter(d => d !== 'measures');\n    }\n\n    return pivotConfig;\n  }\n\n  normalizePivotConfig(pivotConfig) {\n    return ResultSet.getNormalizedPivotConfig(this.loadResponse.pivotQuery, pivotConfig);\n  }\n\n  timeSeries(timeDimension, resultIndex) {\n    if (!timeDimension.granularity) {\n      return null;\n    }\n\n    let { dateRange } = timeDimension;\n\n    if (!dateRange) {\n      const member = ResultSet.timeDimensionMember(timeDimension);\n      const dates = pipe(\n        map(row => row[member] && internalDayjs(row[member])),\n        filter(Boolean)\n      )(this.timeDimensionBackwardCompatibleData(resultIndex));\n\n      dateRange = dates.length && [\n        reduce(minBy(d => d.toDate()), dates[0], dates),\n        reduce(maxBy(d => d.toDate()), dates[0], dates)\n      ] || null;\n    }\n\n    if (!dateRange) {\n      return null;\n    }\n\n    const padToDay = timeDimension.dateRange ?\n      timeDimension.dateRange.find(d => d.match(DateRegex)) :\n      !['hour', 'minute', 'second'].includes(timeDimension.granularity);\n\n    const [start, end] = dateRange;\n    const range = dayRange(start, end);\n\n    if (!TIME_SERIES[timeDimension.granularity]) {\n      throw new Error(`Unsupported time granularity: ${timeDimension.granularity}`);\n    }\n\n    return TIME_SERIES[timeDimension.granularity](\n      padToDay ? range.snapTo('d') : range\n    );\n  }\n\n  pivot(pivotConfig) {\n    pivotConfig = this.normalizePivotConfig(pivotConfig);\n    const { pivotQuery: query } = this.loadResponse;\n\n    const pivotImpl = (resultIndex = 0) => {\n      let groupByXAxis = groupByToPairs(({ xValues }) => this.axisValuesString(xValues));\n\n      const measureValue = (row, measure) => row[measure] || 0;\n\n      if (\n        pivotConfig.fillMissingDates &&\n        pivotConfig.x.length === 1 &&\n        (equals(\n          pivotConfig.x,\n          (query.timeDimensions || [])\n            .filter(td => Boolean(td.granularity))\n            .map(td => ResultSet.timeDimensionMember(td))\n        ))\n      ) {\n        const series = this.loadResponses.map(\n          (loadResponse) => this.timeSeries(loadResponse.query.timeDimensions[0], resultIndex)\n        );\n\n        if (series[0]) {\n          groupByXAxis = (rows) => {\n            const byXValues = groupBy(\n              ({ xValues }) => xValues[0],\n              rows\n            );\n            return series[resultIndex].map(d => [d, byXValues[d] || [{ xValues: [d], row: {} }]]);\n          };\n        }\n      }\n\n      const xGrouped = pipe(\n        map(row => this.axisValues(pivotConfig.x, resultIndex)(row).map(xValues => ({ xValues, row }))),\n        unnest,\n        groupByXAxis\n      )(this.timeDimensionBackwardCompatibleData(resultIndex));\n\n      const yValuesMap = {};\n      xGrouped.forEach(([, rows]) => {\n        rows.forEach(({ row }) => {\n          this.axisValues(pivotConfig.y, resultIndex)(row).forEach((values) => {\n            if (Object.keys(row).length > 0) {\n              yValuesMap[values.join()] = values;\n            }\n          });\n        });\n      });\n      const allYValues = Object.values(yValuesMap);\n\n      const measureOnX = Boolean(pivotConfig.x.find(d => d === 'measures'));\n\n      return xGrouped.map(([, rows]) => {\n        const { xValues } = rows[0];\n        const yGrouped = {};\n\n        rows.forEach(({ row }) => {\n          const arr = this.axisValues(pivotConfig.y, resultIndex)(row).map(yValues => ({ yValues, row }));\n          arr.forEach((res) => {\n            yGrouped[this.axisValuesString(res.yValues)] = res;\n          });\n        });\n\n        return {\n          xValues,\n          yValuesArray: unnest(allYValues.map(yValues => {\n            const measure = measureOnX ?\n              ResultSet.measureFromAxis(xValues) :\n              ResultSet.measureFromAxis(yValues);\n\n            return [[yValues, measureValue((yGrouped[this.axisValuesString(yValues)] ||\n              ({ row: {} })).row, measure)]];\n          }))\n        };\n      });\n    };\n\n    const pivots = this.loadResponses.length > 1\n      ? this.loadResponses.map((_, index) => pivotImpl(index))\n      : [];\n\n    return pivots.length\n      ? this.mergePivots(pivots, pivotConfig.joinDateRange)\n      : pivotImpl();\n  }\n\n  mergePivots(pivots, joinDateRange) {\n    const minLengthPivot = pivots.reduce(\n      (memo, current) => (memo != null && current.length >= memo.length ? memo : current), null\n    );\n\n    return minLengthPivot.map((_, index) => {\n      const xValues = joinDateRange\n        ? [pivots.map((pivot) => pivot[index] && pivot[index].xValues || []).join(', ')]\n        : minLengthPivot[index].xValues;\n\n      return {\n        xValues,\n        yValuesArray: unnest(pivots.map((pivot) => pivot[index].yValuesArray))\n      };\n    });\n  }\n\n  pivotedRows(pivotConfig) { // TODO\n    return this.chartPivot(pivotConfig);\n  }\n\n  chartPivot(pivotConfig) {\n    const validate = (value) => {\n      if (this.parseDateMeasures && LocalDateRegex.test(value)) {\n        return new Date(value);\n      } else if (!Number.isNaN(Number.parseFloat(value))) {\n        return Number.parseFloat(value);\n      }\n\n      return value;\n    };\n\n    const duplicateMeasures = new Set();\n    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n      const allMeasures = flatten(this.loadResponses.map(({ query }) => query.measures));\n      allMeasures.filter((e, i, a) => a.indexOf(e) !== i).forEach(m => duplicateMeasures.add(m));\n    }\n\n    return this.pivot(pivotConfig).map(({ xValues, yValuesArray }) => {\n      const yValuesMap = {};\n\n      yValuesArray\n        .forEach(([yValues, m], i) => {\n          yValuesMap[this.axisValuesString(aliasSeries(yValues, i, pivotConfig, duplicateMeasures), ',')] = m && validate(m);\n        });\n\n      return ({\n        x: this.axisValuesString(xValues, ','),\n        xValues,\n        ...yValuesMap\n      });\n    });\n  }\n\n  tablePivot(pivotConfig) {\n    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});\n    const isMeasuresPresent = normalizedPivotConfig.x.concat(normalizedPivotConfig.y).includes('measures');\n\n    return this.pivot(normalizedPivotConfig).map(({ xValues, yValuesArray }) => fromPairs(\n      normalizedPivotConfig.x\n        .map((key, index) => [key, xValues[index]])\n        .concat(\n          isMeasuresPresent ? yValuesArray.map(([yValues, measure]) => [\n            yValues.length ? yValues.join() : 'value',\n            measure\n          ]) : []\n        )\n    ));\n  }\n\n  tableColumns(pivotConfig) {\n    const normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});\n    const annotations = pipe(\n      pluck('annotation'),\n      reduce(mergeDeepLeft(), {})\n    )(this.loadResponses);\n    const flatMeta = Object.values(annotations).reduce((a, b) => ({ ...a, ...b }), {});\n    const schema = {};\n\n    const extractFields = (key) => {\n      const { title, shortTitle, type, format, meta } = flatMeta[key] || {};\n\n      return {\n        key,\n        title,\n        shortTitle,\n        type,\n        format,\n        meta\n      };\n    };\n\n    const pivot = this.pivot(normalizedPivotConfig);\n\n    (pivot[0] && pivot[0].yValuesArray || []).forEach(([yValues]) => {\n      if (yValues.length > 0) {\n        let currentItem = schema;\n\n        yValues.forEach((value, index) => {\n          currentItem[`_${value}`] = {\n            key: value,\n            memberId: normalizedPivotConfig.y[index] === 'measures'\n              ? value\n              : normalizedPivotConfig.y[index],\n            children: (currentItem[`_${value}`] && currentItem[`_${value}`].children) || {}\n          };\n\n          currentItem = currentItem[`_${value}`].children;\n        });\n      }\n    });\n\n    const toColumns = (item = {}, path = []) => {\n      if (Object.keys(item).length === 0) {\n        return [];\n      }\n\n      return Object.values(item).map(({ key, ...currentItem }) => {\n        const children = toColumns(currentItem.children, [\n          ...path,\n          key\n        ]);\n\n        const { title, shortTitle, ...fields } = extractFields(currentItem.memberId);\n\n        const dimensionValue = key !== currentItem.memberId || title == null ? key : '';\n\n        if (!children.length) {\n          return {\n            ...fields,\n            key,\n            dataIndex: [...path, key].join(),\n            title: [title, dimensionValue].join(' ').trim(),\n            shortTitle: dimensionValue || shortTitle,\n          };\n        }\n\n        return {\n          ...fields,\n          key,\n          title: [title, dimensionValue].join(' ').trim(),\n          shortTitle: dimensionValue || shortTitle,\n          children,\n        };\n      });\n    };\n\n    let otherColumns = [];\n\n    if (!pivot.length && normalizedPivotConfig.y.includes('measures')) {\n      otherColumns = (this.loadResponses[0].query.measures || []).map(\n        (key) => ({ ...extractFields(key), dataIndex: key })\n      );\n    }\n\n    // Syntatic column to display the measure value\n    if (!normalizedPivotConfig.y.length && normalizedPivotConfig.x.includes('measures')) {\n      otherColumns.push({\n        key: 'value',\n        dataIndex: 'value',\n        title: 'Value',\n        shortTitle: 'Value',\n        type: 'string',\n      });\n    }\n\n    return normalizedPivotConfig.x\n      .map((key) => {\n        if (key === 'measures') {\n          return {\n            key: 'measures',\n            dataIndex: 'measures',\n            title: 'Measures',\n            shortTitle: 'Measures',\n            type: 'string',\n          };\n        }\n\n        return ({ ...extractFields(key), dataIndex: key });\n      })\n      .concat(toColumns(schema))\n      .concat(otherColumns);\n  }\n\n  totalRow(pivotConfig) {\n    return this.chartPivot(pivotConfig)[0];\n  }\n\n  categories(pivotConfig) { // TODO\n    return this.chartPivot(pivotConfig);\n  }\n\n  seriesNames(pivotConfig) {\n    pivotConfig = this.normalizePivotConfig(pivotConfig);\n    const measures = pipe(\n      pluck('annotation'),\n      pluck('measures'),\n      mergeAll\n    )(this.loadResponses);\n\n    const seriesNames = unnest(this.loadResponses.map((_, index) => pipe(\n      map(this.axisValues(pivotConfig.y, index)),\n      unnest,\n      uniq\n    )(\n      this.timeDimensionBackwardCompatibleData(index)\n    )));\n    const duplicateMeasures = new Set();\n    if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n      const allMeasures = flatten(this.loadResponses.map(({ query }) => query.measures));\n      allMeasures.filter((e, i, a) => a.indexOf(e) !== i).forEach(m => duplicateMeasures.add(m));\n    }\n\n    return seriesNames.map((axisValues, i) => {\n      const aliasedAxis = aliasSeries(axisValues, i, pivotConfig, duplicateMeasures);\n      return {\n        title: this.axisValuesString(\n          pivotConfig.y.find(d => d === 'measures') ?\n            dropLast(1, aliasedAxis).concat(\n              measures[\n                ResultSet.measureFromAxis(axisValues)\n              ].title\n            ) :\n            aliasedAxis, ', '\n        ),\n        shortTitle: this.axisValuesString(\n          pivotConfig.y.find(d => d === 'measures') ?\n            dropLast(1, aliasedAxis).concat(\n              measures[\n                ResultSet.measureFromAxis(axisValues)\n              ].shortTitle\n            ) :\n            aliasedAxis, ', '\n        ),\n        key: this.axisValuesString(aliasedAxis, ','),\n        yValues: axisValues\n      };\n    });\n  }\n\n  query() {\n    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);\n    }\n\n    return this.loadResponses[0].query;\n  }\n\n  pivotQuery() {\n    return this.loadResponse.pivotQuery || null;\n  }\n\n  totalRows() {\n    return this.loadResponses[0].total;\n  }\n\n  rawData() {\n    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);\n    }\n\n    return this.loadResponses[0].data;\n  }\n\n  annotation() {\n    if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n      throw new Error(`Method is not supported for a '${this.queryType}' query type. Please use decompose`);\n    }\n\n    return this.loadResponses[0].annotation;\n  }\n\n  timeDimensionBackwardCompatibleData(resultIndex) {\n    if (resultIndex === undefined) {\n      throw new Error('resultIndex is required');\n    }\n\n    if (!this.backwardCompatibleData[resultIndex]) {\n      const { data, query } = this.loadResponses[resultIndex];\n      const timeDimensions = (query.timeDimensions || []).filter(td => Boolean(td.granularity));\n\n      this.backwardCompatibleData[resultIndex] = data.map(row => (\n        {\n          ...row,\n          ...(\n            fromPairs(Object.keys(row)\n              .filter(\n                field => timeDimensions.find(d => d.dimension === field) &&\n                  !row[ResultSet.timeDimensionMember(timeDimensions.find(d => d.dimension === field))]\n              ).map(field => (\n                [ResultSet.timeDimensionMember(timeDimensions.find(d => d.dimension === field)), row[field]]\n              )))\n          )\n        }\n      ));\n    }\n\n    return this.backwardCompatibleData[resultIndex];\n  }\n\n  decompose() {\n    return this.loadResponses.map((result) => new ResultSet({\n      queryType: QUERY_TYPE.REGULAR_QUERY,\n      pivotQuery: {\n        ...result.query,\n        queryType: QUERY_TYPE.REGULAR_QUERY,\n      },\n      results: [result]\n    }, this.options));\n  }\n\n  serialize() {\n    return {\n      loadResponse: clone(this.loadResponse)\n    };\n  }\n}\n\nexport default ResultSet;\n","export default class SqlQuery {\n  constructor(sqlQuery) {\n    this.sqlQuery = sqlQuery;\n  }\n\n  rawQuery() {\n    return this.sqlQuery.sql;\n  }\n\n  sql() {\n    return this.rawQuery().sql[0];\n  }\n}\n","/**\n * @module @cubejs-client/core\n */\n\nimport { unnest, fromPairs } from 'ramda';\n\nconst memberMap = (memberArray) => fromPairs(memberArray.map((m) => [m.name, m]));\n\nconst operators = {\n  string: [\n    { name: 'contains', title: 'contains' },\n    { name: 'notContains', title: 'does not contain' },\n    { name: 'equals', title: 'equals' },\n    { name: 'notEquals', title: 'does not equal' },\n    { name: 'set', title: 'is set' },\n    { name: 'notSet', title: 'is not set' },\n    { name: 'startsWith', title: 'starts with' },\n    { name: 'notStartsWith', title: 'does not start with' },\n    { name: 'endsWith', title: 'ends with' },\n    { name: 'notEndsWith', title: 'does not end with' },\n  ],\n  number: [\n    { name: 'equals', title: 'equals' },\n    { name: 'notEquals', title: 'does not equal' },\n    { name: 'set', title: 'is set' },\n    { name: 'notSet', title: 'is not set' },\n    { name: 'gt', title: '>' },\n    { name: 'gte', title: '>=' },\n    { name: 'lt', title: '<' },\n    { name: 'lte', title: '<=' },\n  ],\n  time: [\n    { name: 'equals', title: 'equals' },\n    { name: 'notEquals', title: 'does not equal' },\n    { name: 'inDateRange', title: 'in date range' },\n    { name: 'notInDateRange', title: 'not in date range' },\n    { name: 'afterDate', title: 'after date' },\n    { name: 'afterOrOnDate', title: 'after or on date' },\n    { name: 'beforeDate', title: 'before date' },\n    { name: 'beforeOrOnDate', title: 'before or on date' },\n  ],\n};\n\n/**\n * Contains information about available cubes and it's members.\n */\nclass Meta {\n  constructor(metaResponse) {\n    this.meta = metaResponse;\n    const { cubes } = this.meta;\n    this.cubes = cubes;\n    this.cubesMap = fromPairs(\n      cubes.map((c) => [\n        c.name,\n        {\n          measures: memberMap(c.measures),\n          dimensions: memberMap(c.dimensions),\n          segments: memberMap(c.segments),\n        },\n      ])\n    );\n  }\n\n  membersForQuery(query, memberType) {\n    return unnest(this.cubes.map((c) => c[memberType])).sort((a, b) => (a.title > b.title ? 1 : -1));\n  }\n\n  membersGroupedByCube() {\n    const memberKeys = ['measures', 'dimensions', 'segments', 'timeDimensions'];\n\n    return this.cubes.reduce(\n      (memo, cube) => {\n        memberKeys.forEach((key) => {\n          let members = cube[key];\n\n          if (key === 'timeDimensions') {\n            members = cube.dimensions.filter((m) => m.type === 'time');\n          }\n\n          memo[key] = [\n            ...memo[key],\n            {\n              cubeName: cube.name,\n              cubeTitle: cube.title,\n              type: cube.type,\n              public: cube.public,\n              members\n            },\n          ];\n        });\n\n        return memo;\n      },\n      {\n        measures: [],\n        dimensions: [],\n        segments: [],\n        timeDimensions: [],\n      }\n    );\n  }\n\n  resolveMember(memberName, memberType) {\n    const [cube] = memberName.split('.');\n\n    if (!this.cubesMap[cube]) {\n      return { title: memberName, error: `Cube not found ${cube} for path '${memberName}'` };\n    }\n\n    const memberTypes = Array.isArray(memberType) ? memberType : [memberType];\n    const member = memberTypes\n      .map((type) => this.cubesMap[cube][type] && this.cubesMap[cube][type][memberName])\n      .find((m) => m);\n\n    if (!member) {\n      return {\n        title: memberName,\n        error: `Path not found '${memberName}'`,\n      };\n    }\n\n    return member;\n  }\n\n  defaultTimeDimensionNameFor(memberName) {\n    const [cube] = memberName.split('.');\n    if (!this.cubesMap[cube]) {\n      return null;\n    }\n    return Object.keys(this.cubesMap[cube].dimensions || {}).find(\n      (d) => this.cubesMap[cube].dimensions[d].type === 'time'\n    );\n  }\n\n  filterOperatorsForMember(memberName, memberType) {\n    const member = this.resolveMember(memberName, memberType);\n\n    return operators[member.type] || operators.string;\n  }\n}\n\nexport default Meta;\n","export default class ProgressResult {\n  constructor(progressResponse) {\n    this.progressResponse = progressResponse;\n  }\n\n  stage() {\n    return this.progressResponse.stage;\n  }\n\n  timeElapsed() {\n    return this.progressResponse.timeElapsed;\n  }\n}\n","import fetch from 'cross-fetch';\nimport 'url-search-params-polyfill';\n\nclass HttpTransport {\n  constructor({ authorization, apiUrl, method, headers = {}, credentials }) {\n    this.authorization = authorization;\n    this.apiUrl = apiUrl;\n    this.method = method;\n    this.headers = headers;\n    this.credentials = credentials;\n  }\n\n  request(method, { baseRequestId, ...params }) {\n    let spanCounter = 1;\n    const searchParams = new URLSearchParams(\n      params && Object.keys(params)\n        .map(k => ({ [k]: typeof params[k] === 'object' ? JSON.stringify(params[k]) : params[k] }))\n        .reduce((a, b) => ({ ...a, ...b }), {})\n    );\n\n    let url = `${this.apiUrl}/${method}${searchParams.toString().length ? `?${searchParams}` : ''}`;\n\n    const requestMethod = this.method || (url.length < 2000 ? 'GET' : 'POST');\n    if (requestMethod === 'POST') {\n      url = `${this.apiUrl}/${method}`;\n      this.headers['Content-Type'] = 'application/json';\n    }\n\n    // Currently, all methods make GET requests. If a method makes a request with a body payload,\n    // remember to add {'Content-Type': 'application/json'} to the header.\n    const runRequest = () => fetch(url, {\n      method: requestMethod,\n      headers: {\n        Authorization: this.authorization,\n        'x-request-id': baseRequestId && `${baseRequestId}-span-${spanCounter++}`,\n        ...this.headers\n      },\n      credentials: this.credentials,\n      body: requestMethod === 'POST' ? JSON.stringify(params) : null\n    });\n\n    return {\n      /* eslint no-unsafe-finally: off */\n      async subscribe(callback) {\n        let result = {\n          error: 'network Error' // add default error message\n        };\n        try {\n          result = await runRequest();\n        } finally {\n          return callback(result, () => this.subscribe(callback));\n        }\n      }\n    };\n  }\n}\n\nexport default HttpTransport;\n","export default class RequestError extends Error {\n  constructor(message, response, status) {\n    super(message);\n    this.response = response;\n    this.status = status;\n  }\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport ResultSet from './ResultSet';\nimport SqlQuery from './SqlQuery';\nimport Meta from './Meta';\nimport ProgressResult from './ProgressResult';\nimport HttpTransport from './HttpTransport';\nimport RequestError from './RequestError';\n\nlet mutexCounter = 0;\n\nconst MUTEX_ERROR = 'Mutex has been changed';\n\n/**\n * Query result dataset formats enum.\n */\nconst ResultType = {\n  DEFAULT: 'default',\n  COMPACT: 'compact'\n};\n\nfunction mutexPromise(promise) {\n  return new Promise(async (resolve, reject) => {\n    try {\n      resolve(await promise);\n    } catch (error) {\n      if (error !== MUTEX_ERROR) {\n        reject(error);\n      }\n    }\n  });\n}\n\nclass CubeApi {\n  constructor(apiToken, options) {\n    if (apiToken !== null && !Array.isArray(apiToken) && typeof apiToken === 'object') {\n      options = apiToken;\n      apiToken = undefined;\n    }\n    options = options || {};\n\n    if (!options.transport && !options.apiUrl) {\n      throw new Error('The `apiUrl` option is required');\n    }\n\n    this.apiToken = apiToken;\n    this.apiUrl = options.apiUrl;\n    this.method = options.method;\n    this.headers = options.headers || {};\n    this.credentials = options.credentials;\n    this.transport = options.transport || new HttpTransport({\n      authorization: typeof apiToken === 'function' ? undefined : apiToken,\n      apiUrl: this.apiUrl,\n      method: this.method,\n      headers: this.headers,\n      credentials: this.credentials\n    });\n    this.pollInterval = options.pollInterval || 5;\n    this.parseDateMeasures = options.parseDateMeasures;\n    this.castNumerics = typeof options.castNumerics === 'boolean' ? options.castNumerics : false;\n\n    this.updateAuthorizationPromise = null;\n  }\n\n  request(method, params) {\n    return this.transport.request(method, {\n      baseRequestId: uuidv4(),\n      ...params\n    });\n  }\n\n  loadMethod(request, toResult, options, callback) {\n    const mutexValue = ++mutexCounter;\n    if (typeof options === 'function' && !callback) {\n      callback = options;\n      options = undefined;\n    }\n\n    options = options || {};\n\n    const mutexKey = options.mutexKey || 'default';\n    if (options.mutexObj) {\n      options.mutexObj[mutexKey] = mutexValue;\n    }\n\n    const requestPromise = this\n      .updateTransportAuthorization()\n      .then(() => request());\n\n    let skipAuthorizationUpdate = true;\n    let unsubscribed = false;\n\n    const checkMutex = async () => {\n      const requestInstance = await requestPromise;\n\n      if (\n        options.mutexObj &&\n        options.mutexObj[mutexKey] !== mutexValue\n      ) {\n        unsubscribed = true;\n        if (requestInstance.unsubscribe) {\n          await requestInstance.unsubscribe();\n        }\n        throw MUTEX_ERROR;\n      }\n    };\n\n    const loadImpl = async (response, next) => {\n      const requestInstance = await requestPromise;\n\n      const subscribeNext = async () => {\n        if (options.subscribe && !unsubscribed) {\n          if (requestInstance.unsubscribe) {\n            return next();\n          } else {\n            await new Promise(resolve => setTimeout(() => resolve(), this.pollInterval * 1000));\n            return next();\n          }\n        }\n        return null;\n      };\n\n      const continueWait = async (wait) => {\n        if (!unsubscribed) {\n          if (wait) {\n            await new Promise(resolve => setTimeout(() => resolve(), this.pollInterval * 1000));\n          }\n          return next();\n        }\n        return null;\n      };\n\n      if (options.subscribe && !skipAuthorizationUpdate) {\n        await this.updateTransportAuthorization();\n      }\n\n      skipAuthorizationUpdate = false;\n\n      if (response.status === 502) {\n        await checkMutex();\n        return continueWait(true);\n      }\n\n      let body = {};\n      let text = '';\n      try {\n        text = await response.text();\n        body = JSON.parse(text);\n      } catch (_) {\n        body.error = text;\n      }\n\n      if (body.error === 'Continue wait') {\n        await checkMutex();\n        if (options.progressCallback) {\n          options.progressCallback(new ProgressResult(body));\n        }\n        return continueWait();\n      }\n\n      if (response.status !== 200) {\n        await checkMutex();\n        if (!options.subscribe && requestInstance.unsubscribe) {\n          await requestInstance.unsubscribe();\n        }\n\n        const error = new RequestError(body.error, body, response.status); // TODO error class\n        if (callback) {\n          callback(error);\n        } else {\n          throw error;\n        }\n\n        return subscribeNext();\n      }\n      await checkMutex();\n      if (!options.subscribe && requestInstance.unsubscribe) {\n        await requestInstance.unsubscribe();\n      }\n      const result = toResult(body);\n      if (callback) {\n        callback(null, result);\n      } else {\n        return result;\n      }\n\n      return subscribeNext();\n    };\n\n    const promise = requestPromise.then(requestInstance => mutexPromise(requestInstance.subscribe(loadImpl)));\n\n    if (callback) {\n      return {\n        unsubscribe: async () => {\n          const requestInstance = await requestPromise;\n\n          unsubscribed = true;\n          if (requestInstance.unsubscribe) {\n            return requestInstance.unsubscribe();\n          }\n          return null;\n        }\n      };\n    } else {\n      return promise;\n    }\n  }\n\n  async updateTransportAuthorization() {\n    if (this.updateAuthorizationPromise) {\n      await this.updateAuthorizationPromise;\n      return;\n    }\n\n    if (typeof this.apiToken === 'function') {\n      this.updateAuthorizationPromise = new Promise(async (resolve, reject) => {\n        try {\n          const token = await this.apiToken();\n          if (this.transport.authorization !== token) {\n            this.transport.authorization = token;\n          }\n          resolve();\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.updateAuthorizationPromise = null;\n        }\n      });\n\n      await this.updateAuthorizationPromise;\n    }\n  }\n\n  /**\n   * Add system properties to a query object.\n   * @param {Query} query\n   * @param {string} responseFormat\n   * @returns {void}\n   * @private\n   */\n  patchQueryInternal(query, responseFormat) {\n    if (\n      responseFormat === ResultType.COMPACT &&\n      query.responseFormat !== ResultType.COMPACT\n    ) {\n      return {\n        ...query,\n        responseFormat: ResultType.COMPACT,\n      };\n    } else {\n      return query;\n    }\n  }\n\n  /**\n   * Process result fetched from the gateway#load method according\n   * to the network protocol.\n   * @param {*} response\n   * @returns ResultSet\n   * @private\n   */\n  loadResponseInternal(response, options = {}) {\n    if (\n      response.results.length\n    ) {\n      if (options.castNumerics) {\n        response.results.forEach((result) => {\n          const numericMembers = Object.entries({\n            ...result.annotation.measures,\n            ...result.annotation.dimensions,\n          }).map(([k, v]) => {\n            if (v.type === 'number') {\n              return k;\n            }\n            \n            return undefined;\n          }).filter(Boolean);\n          \n          result.data = result.data.map((row) => {\n            numericMembers.forEach((key) => {\n              if (row[key] != null) {\n                row[key] = Number(row[key]);\n              }\n            });\n            \n            return row;\n          });\n        });\n      }\n      \n      if (response.results[0].query.responseFormat &&\n        response.results[0].query.responseFormat === ResultType.COMPACT) {\n        response.results.forEach((result, j) => {\n          const data = [];\n          result.data.dataset.forEach((r) => {\n            const row = {};\n            result.data.members.forEach((m, i) => {\n              row[m] = r[i];\n            });\n            data.push(row);\n          });\n          response.results[j].data = data;\n        });\n      }\n    }\n    \n    return new ResultSet(response, {\n      parseDateMeasures: this.parseDateMeasures\n    });\n  }\n\n  load(query, options, callback, responseFormat = ResultType.DEFAULT) {\n    options = {\n      castNumerics: this.castNumerics,\n      ...options\n    };\n\n    if (responseFormat === ResultType.COMPACT) {\n      if (Array.isArray(query)) {\n        query = query.map((q) => this.patchQueryInternal(q, ResultType.COMPACT));\n      } else {\n        query = this.patchQueryInternal(query, ResultType.COMPACT);\n      }\n    }\n    return this.loadMethod(\n      () => this.request('load', {\n        query,\n        queryType: 'multi',\n      }),\n      (response) => this.loadResponseInternal(response, options),\n      options,\n      callback\n    );\n  }\n\n  subscribe(query, options, callback, responseFormat = ResultType.DEFAULT) {\n    options = {\n      castNumerics: this.castNumerics,\n      ...options\n    };\n\n    if (responseFormat === ResultType.COMPACT) {\n      if (Array.isArray(query)) {\n        query = query.map((q) => this.patchQueryInternal(q, ResultType.COMPACT));\n      } else {\n        query = this.patchQueryInternal(query, ResultType.COMPACT);\n      }\n    }\n    return this.loadMethod(\n      () => this.request('subscribe', {\n        query,\n        queryType: 'multi',\n      }),\n      (response) => this.loadResponseInternal(response, options),\n      { ...options, subscribe: true },\n      callback\n    );\n  }\n\n  sql(query, options, callback) {\n    return this.loadMethod(\n      () => this.request('sql', { query }),\n      (response) => (Array.isArray(response) ? response.map((body) => new SqlQuery(body)) : new SqlQuery(response)),\n      options,\n      callback\n    );\n  }\n\n  meta(options, callback) {\n    return this.loadMethod(\n      () => this.request('meta'),\n      (body) => new Meta(body),\n      options,\n      callback\n    );\n  }\n\n  dryRun(query, options, callback) {\n    return this.loadMethod(\n      () => this.request('dry-run', { query }),\n      (response) => response,\n      options,\n      callback\n    );\n  }\n}\n\nexport default (apiToken, options) => new CubeApi(apiToken, options);\n\nexport { CubeApi, HttpTransport, ResultSet, RequestError, Meta };\nexport * from './utils';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}